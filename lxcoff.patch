
project dalvik/
diff --git a/vm/analysis/DexPrepare.cpp b/vm/analysis/DexPrepare.cpp
index e8112d5..af5ff03 100644
--- a/vm/analysis/DexPrepare.cpp
+++ b/vm/analysis/DexPrepare.cpp
@@ -1314,6 +1314,7 @@ bool dvmCheckOptHeaderAndDependencies(int fd, bool sourceAvail, u4 modWhen,
         }
 
         storedStrLen = read4LE(&ptr);
+        /*
         if (len != storedStrLen ||
             strcmp(cacheFileName, (const char*) ptr) != 0)
         {
@@ -1321,13 +1322,16 @@ bool dvmCheckOptHeaderAndDependencies(int fd, bool sourceAvail, u4 modWhen,
                 cacheFileName, ptr);
             goto bail;
         }
+        */
 
         ptr += storedStrLen;
 
+        /*
         if (memcmp(signature, ptr, kSHA1DigestLen) != 0) {
             ALOGI("DexOpt: mismatch dep signature for '%s'", cacheFileName);
             goto bail;
         }
+        */
         ptr += kSHA1DigestLen;
 
         ALOGV("DexOpt: dep match on '%s'", cacheFileName);

project frameworks/base/
diff --git a/services/java/com/android/server/ConnectivityService.java b/services/java/com/android/server/ConnectivityService.java
index 41a0e6b..3d48b06 100644
--- a/services/java/com/android/server/ConnectivityService.java
+++ b/services/java/com/android/server/ConnectivityService.java
@@ -734,8 +734,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                     return BluetoothTetheringDataTracker.getInstance();
                 case TYPE_WIMAX:
                     return makeWimaxStateTracker(mContext, mTrackerHandler);
-                case TYPE_ETHERNET:
-                    return EthernetDataTracker.getInstance();
+               // case TYPE_ETHERNET:
+               //     return EthernetDataTracker.getInstance();
                 default:
                     throw new IllegalArgumentException(
                             "Trying to create a NetworkStateTracker for an unknown radio type: "
diff --git a/services/java/com/android/server/NativeDaemonConnector.java b/services/java/com/android/server/NativeDaemonConnector.java
index 417d6d8..e4aa664 100644
--- a/services/java/com/android/server/NativeDaemonConnector.java
+++ b/services/java/com/android/server/NativeDaemonConnector.java
@@ -88,7 +88,8 @@ final class NativeDaemonConnector implements Runnable, Handler.Callback, Watchdo
                 listenToSocket();
             } catch (Exception e) {
                 loge("Error in NativeDaemonConnector: " + e);
-                SystemClock.sleep(5000);
+                //SystemClock.sleep(5000);
+                SystemClock.sleep(100);
             }
         }
     }
diff --git a/services/java/com/android/server/NetworkManagementService.java b/services/java/com/android/server/NetworkManagementService.java
index 72fce62..68a6ce1 100644
--- a/services/java/com/android/server/NetworkManagementService.java
+++ b/services/java/com/android/server/NetworkManagementService.java
@@ -93,7 +93,7 @@ import java.util.concurrent.CountDownLatch;
 public class NetworkManagementService extends INetworkManagementService.Stub
         implements Watchdog.Monitor {
     private static final String TAG = "NetworkManagementService";
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
     private static final String NETD_TAG = "NetdConnector";
     private static final String NETD_SOCKET_NAME = "netd";
 
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index a42cbcf..3c38f05 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -356,7 +356,7 @@ class ServerThread {
         LockSettingsService lockSettings = null;
         DreamManagerService dreamy = null;
         AssetAtlasService atlas = null;
-        PrintManagerService printManager = null;
+        //PrintManagerService printManager = null;
         MediaRouterService mediaRouter = null;
 
         // Bring up services needed for UI.
@@ -799,6 +799,7 @@ class ServerThread {
                 reportWtf("starting IdleMaintenanceService", e);
             }
 
+	    /*
             try {
                 Slog.i(TAG, "Print Service");
                 printManager = new PrintManagerService(context);
@@ -806,6 +807,7 @@ class ServerThread {
             } catch (Throwable e) {
                 reportWtf("starting Print Service", e);
             }
+	    */
 
             if (!disableNonCoreServices) {
                 try {
@@ -927,7 +929,7 @@ class ServerThread {
         final AssetAtlasService atlasF = atlas;
         final InputManagerService inputManagerF = inputManager;
         final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
-        final PrintManagerService printManagerF = printManager;
+        //final PrintManagerService printManagerF = printManager;
         final MediaRouterService mediaRouterF = mediaRouter;
 
         // We now tell the activity manager it is okay to run third party
@@ -1071,11 +1073,13 @@ class ServerThread {
                     reportWtf("Notifying TelephonyRegistry running", e);
                 }
 
+		/*
                 try {
                     if (printManagerF != null) printManagerF.systemRuning();
                 } catch (Throwable e) {
                     reportWtf("Notifying PrintManagerService running", e);
                 }
+		*/
 
                 try {
                     if (mediaRouterF != null) mediaRouterF.systemRunning();

project frameworks/opt/telephony/
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 0e2a73e..bbe855d 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -166,7 +166,8 @@ public class GSMPhone extends PhoneBase {
         mCi.setOnUSSD(this, EVENT_USSD, null);
         mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
         mSST.registerForNetworkAttached(this, EVENT_REGISTERED_TO_NETWORK, null);
-
+	
+	/*
         if (DBG_PORT) {
             try {
                 //debugSocket = new LocalServerSocket("com.android.internal.telephony.debug");
@@ -201,6 +202,7 @@ public class GSMPhone extends PhoneBase {
                 Rlog.w(LOG_TAG, "Failure to open com.android.internal.telephony.debug socket", ex);
             }
         }
+	*/
 
         //Change the system property
         SystemProperties.set(TelephonyProperties.CURRENT_ACTIVE_PHONE,

project kernel/
diff --git a/MAINTAINERS b/MAINTAINERS
index 738708f..91755dd 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1795,6 +1795,20 @@ F:	include/linux/audit.h
 F:	include/uapi/linux/audit.h
 F:	kernel/audit*
 
+AUFS (advanced multi layered unification filesystem) FILESYSTEM
+M:	"J. R. Okajima" <hooanon05g@gmail.com>
+L:	linux-unionfs@vger.kernel.org
+L:	aufs-users@lists.sourceforge.net (members only)
+W:	http://aufs.sourceforge.net
+T:	git://git.code.sf.net/p/aufs/aufs3-linux
+T:	git://github.com/sfjro/aufs3-linux.git
+S:	Supported
+F:	Documentation/filesystems/aufs/
+F:	Documentation/ABI/testing/debugfs-aufs
+F:	Documentation/ABI/testing/sysfs-aufs
+F:	fs/aufs/
+F:	include/uapi/linux/aufs_type.h
+
 AUXILIARY DISPLAY DRIVERS
 M:	Miguel Ojeda Sandonis <miguel.ojeda.sandonis@gmail.com>
 W:	http://miguelojeda.es/auxdisplay.htm
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index 6cb1beb..30efd68 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -692,6 +692,24 @@ static inline int is_loop_device(struct file *file)
 	return i && S_ISBLK(i->i_mode) && MAJOR(i->i_rdev) == LOOP_MAJOR;
 }
 
+/*
+ * for AUFS
+ * no get/put for file.
+ */
+struct file *loop_backing_file(struct super_block *sb)
+{
+	struct file *ret;
+	struct loop_device *l;
+
+	ret = NULL;
+	if (MAJOR(sb->s_dev) == LOOP_MAJOR) {
+		l = sb->s_bdev->bd_disk->private_data;
+		ret = l->lo_backing_file;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(loop_backing_file);
+
 /* loop sysfs attributes */
 
 static ssize_t loop_attr_show(struct device *dev, char *page,
diff --git a/drivers/staging/android/alarm-dev.c b/drivers/staging/android/alarm-dev.c
index be71d17..df2220e 100644
--- a/drivers/staging/android/alarm-dev.c
+++ b/drivers/staging/android/alarm-dev.c
@@ -23,32 +23,16 @@
 #include <linux/spinlock.h>
 #include <linux/uaccess.h>
 #include <linux/alarmtimer.h>
+#include <linux/wakelock.h>
+#include <linux/slab.h>
+#include <linux/dev_namespace.h>
 #include "android_alarm.h"
 
 #define ANDROID_ALARM_PRINT_INFO (1U << 0)
 #define ANDROID_ALARM_PRINT_IO (1U << 1)
 #define ANDROID_ALARM_PRINT_INT (1U << 2)
 
-static int debug_mask = ANDROID_ALARM_PRINT_INFO;
-module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
-
-#define alarm_dbg(debug_level_mask, fmt, ...)				\
-do {									\
-	if (debug_mask & ANDROID_ALARM_PRINT_##debug_level_mask)	\
-		pr_info(fmt, ##__VA_ARGS__);				\
-} while (0)
-
-#define ANDROID_ALARM_WAKEUP_MASK ( \
-	ANDROID_ALARM_RTC_WAKEUP_MASK | \
-	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
-
-static int alarm_opened;
-static DEFINE_SPINLOCK(alarm_slock);
-static struct wakeup_source alarm_wake_lock;
-static DECLARE_WAIT_QUEUE_HEAD(alarm_wait_queue);
-static uint32_t alarm_pending;
-static uint32_t alarm_enabled;
-static uint32_t wait_pending;
+struct alarm_dev_ns;
 
 struct devalarm {
 	union {
@@ -56,264 +40,340 @@ struct devalarm {
 		struct alarm alrm;
 	} u;
 	enum android_alarm_type type;
+
+	struct alarm_dev_ns *alarm_ns;
 };
 
-static struct devalarm alarms[ANDROID_ALARM_TYPE_COUNT];
+struct alarm_dev_ns {
+	int               alarm_opened;
+	spinlock_t        alarm_slock;
+	struct wake_lock  alarm_wake_lock;
+	wait_queue_head_t alarm_wait_queue;
+	uint32_t          alarm_pending;
+	uint32_t          alarm_enabled;
+	uint32_t          wait_pending;
 
-/**
- * is_wakeup() - Checks to see if this alarm can wake the device
- * @type:	 The type of alarm being checked
- *
- * Return: 1 if this is a wakeup alarm, otherwise 0
- */
-static int is_wakeup(enum android_alarm_type type)
-{
-	return type == ANDROID_ALARM_RTC_WAKEUP ||
-		type == ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP;
-}
+	struct devalarm   alarms[ANDROID_ALARM_TYPE_COUNT];
+	char wakelock_name[32];
 
-static void devalarm_start(struct devalarm *alrm, ktime_t exp)
+	struct dev_ns_info dev_ns_info;
+};
+
+static int debug_mask = ANDROID_ALARM_PRINT_INFO;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+#define pr_alarm(debug_level_mask, args...) \
+	do { \
+		if (debug_mask & ANDROID_ALARM_PRINT_##debug_level_mask) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define ANDROID_ALARM_WAKEUP_MASK ( \
+	ANDROID_ALARM_RTC_WAKEUP_MASK | \
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
+
+/* support old usespace code */
+#define ANDROID_ALARM_SET_OLD               _IOW('a', 2, time_t) /* set alarm */
+#define ANDROID_ALARM_SET_AND_WAIT_OLD      _IOW('a', 3, time_t)
+
+static void devalarm_alarms_init(struct devalarm *alarms);
+
+static void alarm_ns_initialize(struct alarm_dev_ns *alarm_ns)
 {
-	if (is_wakeup(alrm->type))
-		alarm_start(&alrm->u.alrm, exp);
-	else
-		hrtimer_start(&alrm->u.hrt, exp, HRTIMER_MODE_ABS);
+	alarm_ns->alarm_slock = __SPIN_LOCK_UNLOCKED(alarm_ns->alarm_slock);
+	init_waitqueue_head(&alarm_ns->alarm_wait_queue);
+
+	alarm_ns->alarm_pending = 0;
+	alarm_ns->alarm_enabled = 0;
+	alarm_ns->wait_pending = 0;
+
+	devalarm_alarms_init(alarm_ns->alarms);
+
+#ifdef CONFIG_DEV_NS
+	/* encode device-namespace into wakelock to ensure uniqueness */
+	sprintf(alarm_ns->wakelock_name, "alarm[ns:%d]",
+		dev_ns_init_pid(current_dev_ns()));
+#else
+	sprintf(alarm_ns->wakelock_name, "alarm");
+#endif
+
+	wake_lock_init(&alarm_ns->alarm_wake_lock, WAKE_LOCK_SUSPEND,
+		       alarm_ns->wakelock_name);
 }
 
-static int devalarm_try_to_cancel(struct devalarm *alrm)
+static void alarm_ns_destroy(struct alarm_dev_ns *alarm_ns)
 {
-	if (is_wakeup(alrm->type))
-		return alarm_try_to_cancel(&alrm->u.alrm);
-	return hrtimer_try_to_cancel(&alrm->u.hrt);
+	wake_lock_destroy(&alarm_ns->alarm_wake_lock);
 }
 
-static void devalarm_cancel(struct devalarm *alrm)
+#ifdef CONFIG_DEV_NS
+
+/* alarm_ns_id, get_alarm_ns(), get_alarm_ns_cur(), put_alarm_ns() */
+DEFINE_DEV_NS_INFO(alarm)
+
+static struct dev_ns_info *alarm_ns_create(struct dev_namespace *dev_ns)
 {
-	if (is_wakeup(alrm->type))
-		alarm_cancel(&alrm->u.alrm);
-	else
-		hrtimer_cancel(&alrm->u.hrt);
+	struct alarm_dev_ns *alarm_ns;
+
+	alarm_ns = kzalloc(sizeof(*alarm_ns), GFP_KERNEL);
+	if (!alarm_ns)
+		return ERR_PTR(-ENOMEM);
+
+	alarm_ns_initialize(alarm_ns);
+    pr_alarm(INFO, "alarm_ns_create finished");
+
+	return &alarm_ns->dev_ns_info;
 }
 
-static void alarm_clear(enum android_alarm_type alarm_type)
+static void alarm_ns_release(struct dev_ns_info *dev_ns_info)
 {
-	uint32_t alarm_type_mask = 1U << alarm_type;
-	unsigned long flags;
+	struct alarm_dev_ns *alarm_ns;
 
-	spin_lock_irqsave(&alarm_slock, flags);
-	alarm_dbg(IO, "alarm %d clear\n", alarm_type);
-	devalarm_try_to_cancel(&alarms[alarm_type]);
-	if (alarm_pending) {
-		alarm_pending &= ~alarm_type_mask;
-		if (!alarm_pending && !wait_pending)
-			__pm_relax(&alarm_wake_lock);
-	}
-	alarm_enabled &= ~alarm_type_mask;
-	spin_unlock_irqrestore(&alarm_slock, flags);
+	alarm_ns = container_of(dev_ns_info, struct alarm_dev_ns, dev_ns_info);
+	alarm_ns_destroy(alarm_ns);
+	kfree(alarm_ns);
 }
 
-static void alarm_set(enum android_alarm_type alarm_type,
-							struct timespec *ts)
+/*
+ * If the RTC is set in any namespace (via alarm_set_rtc), make sure
+ * the remaining namespaces are udpates suitably.
+ */
+
+static void update_alarm_time_change(struct alarm_dev_ns *alarm_ns);
+
+static void propagate_alarm_time_change_func(struct dev_ns_info *dev_ns_info,
+					     void *unused)
 {
-	uint32_t alarm_type_mask = 1U << alarm_type;
-	unsigned long flags;
+	struct alarm_dev_ns *alarm_ns;
 
-	spin_lock_irqsave(&alarm_slock, flags);
-	alarm_dbg(IO, "alarm %d set %ld.%09ld\n",
-			alarm_type, ts->tv_sec, ts->tv_nsec);
-	alarm_enabled |= alarm_type_mask;
-	devalarm_start(&alarms[alarm_type], timespec_to_ktime(*ts));
-	spin_unlock_irqrestore(&alarm_slock, flags);
+	alarm_ns = container_of(dev_ns_info, struct alarm_dev_ns, dev_ns_info);
+	update_alarm_time_change(alarm_ns);
 }
 
-static int alarm_wait(void)
+static void propagate_alarm_time_change(void)
 {
-	unsigned long flags;
-	int rv = 0;
+	loop_dev_ns_info(alarm_ns_id, NULL, propagate_alarm_time_change_func);
+}
 
-	spin_lock_irqsave(&alarm_slock, flags);
-	alarm_dbg(IO, "alarm wait\n");
-	if (!alarm_pending && wait_pending) {
-		__pm_relax(&alarm_wake_lock);
-		wait_pending = 0;
-	}
-	spin_unlock_irqrestore(&alarm_slock, flags);
 
-	rv = wait_event_interruptible(alarm_wait_queue, alarm_pending);
-	if (rv)
-		return rv;
+static struct dev_ns_ops alarm_ns_ops = {
+	.create = alarm_ns_create,
+	.release = alarm_ns_release,
+};
+
+#else
 
-	spin_lock_irqsave(&alarm_slock, flags);
-	rv = alarm_pending;
-	wait_pending = 1;
-	alarm_pending = 0;
-	spin_unlock_irqrestore(&alarm_slock, flags);
+/* init_alarm_ns, get_alarm_ns(), get_alarm_ns_cur(), put_alarm_ns() */
+DEFINE_DEV_NS_INIT(alarm)
 
-	return rv;
+#endif /* CONFIG_DEV_NS */
+
+
+static int is_wakeup(enum android_alarm_type type)
+{
+	if (type == ANDROID_ALARM_RTC_WAKEUP ||
+			type == ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP)
+		return 1;
+	return 0;
 }
 
-static int alarm_set_rtc(struct timespec *ts)
+
+static void devalarm_start(struct devalarm *alrm, ktime_t exp)
 {
-	struct rtc_time new_rtc_tm;
-	struct rtc_device *rtc_dev;
-	unsigned long flags;
-	int rv = 0;
+	if (is_wakeup(alrm->type))
+		alarm_start(&alrm->u.alrm, exp);
+	else
+		hrtimer_start(&alrm->u.hrt, exp, HRTIMER_MODE_ABS);
+}
 
-	rtc_time_to_tm(ts->tv_sec, &new_rtc_tm);
-	rtc_dev = alarmtimer_get_rtcdev();
-	rv = do_settimeofday(ts);
-	if (rv < 0)
-		return rv;
-	if (rtc_dev)
-		rv = rtc_set_time(rtc_dev, &new_rtc_tm);
 
-	spin_lock_irqsave(&alarm_slock, flags);
-	alarm_pending |= ANDROID_ALARM_TIME_CHANGE_MASK;
-	wake_up(&alarm_wait_queue);
-	spin_unlock_irqrestore(&alarm_slock, flags);
+static int devalarm_try_to_cancel(struct devalarm *alrm)
+{
+	int ret;
+	if (is_wakeup(alrm->type))
+		ret = alarm_try_to_cancel(&alrm->u.alrm);
+	else
+		ret = hrtimer_try_to_cancel(&alrm->u.hrt);
+	return ret;
+}
 
-	return rv;
+static void devalarm_cancel(struct devalarm *alrm)
+{
+	if (is_wakeup(alrm->type))
+		alarm_cancel(&alrm->u.alrm);
+	else
+		hrtimer_cancel(&alrm->u.hrt);
 }
 
-static int alarm_get_time(enum android_alarm_type alarm_type,
-							struct timespec *ts)
+static void update_alarm_time_change(struct alarm_dev_ns *alarm_ns)
 {
-	int rv = 0;
+	unsigned long flags;
 
-	switch (alarm_type) {
-	case ANDROID_ALARM_RTC_WAKEUP:
-	case ANDROID_ALARM_RTC:
-		getnstimeofday(ts);
-		break;
-	case ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP:
-	case ANDROID_ALARM_ELAPSED_REALTIME:
-		get_monotonic_boottime(ts);
-		break;
-	case ANDROID_ALARM_SYSTEMTIME:
-		ktime_get_ts(ts);
-		break;
-	default:
-		rv = -EINVAL;
-	}
-	return rv;
+	spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+	alarm_ns->alarm_pending |= ANDROID_ALARM_TIME_CHANGE_MASK;
+	wake_up(&alarm_ns->alarm_wait_queue);
+	spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
 }
 
-static long alarm_do_ioctl(struct file *file, unsigned int cmd,
-							struct timespec *ts)
+static long alarm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int rv = 0;
 	unsigned long flags;
+	struct timespec new_alarm_time;
+	struct timespec new_rtc_time;
+	struct timespec tmp_time;
+	struct rtc_time new_rtc_tm;
+	struct rtc_device *rtc_dev;
 	enum android_alarm_type alarm_type = ANDROID_ALARM_IOCTL_TO_TYPE(cmd);
+	uint32_t alarm_type_mask = 1U << alarm_type;
+	struct alarm_dev_ns *alarm_ns;
+	bool opened = false;
+
+    pr_alarm(INFO, "start alarm_ioctl");
 
 	if (alarm_type >= ANDROID_ALARM_TYPE_COUNT)
 		return -EINVAL;
 
+	alarm_ns = get_alarm_ns_cur();
+	if (!alarm_ns)
+		return -ENOMEM;
+
 	if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_GET_TIME(0)) {
-		if ((file->f_flags & O_ACCMODE) == O_RDONLY)
-			return -EPERM;
+		if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
+			rv = -EPERM;
+			goto err1;
+		}
+
 		if (file->private_data == NULL &&
 		    cmd != ANDROID_ALARM_SET_RTC) {
-			spin_lock_irqsave(&alarm_slock, flags);
-			if (alarm_opened) {
-				spin_unlock_irqrestore(&alarm_slock, flags);
-				return -EBUSY;
+			spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+			if (alarm_ns->alarm_opened) {
+				spin_unlock_irqrestore(&alarm_ns->alarm_slock,
+						       flags);
+				rv = -EBUSY;
+				goto err1;
 			}
-			alarm_opened = 1;
-			file->private_data = (void *)1;
-			spin_unlock_irqrestore(&alarm_slock, flags);
+			opened = true;
+			alarm_ns->alarm_opened = 1;
+			//file->private_data = (void *)1;
+			file->private_data = alarm_ns;
+			spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
 		}
 	}
 
 	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
 	case ANDROID_ALARM_CLEAR(0):
-		alarm_clear(alarm_type);
-		break;
-	case ANDROID_ALARM_SET(0):
-		alarm_set(alarm_type, ts);
+		spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+		pr_alarm(IO, "alarm %d clear\n", alarm_type);
+		devalarm_try_to_cancel(&alarm_ns->alarms[alarm_type]);
+		if (alarm_ns->alarm_pending) {
+			alarm_ns->alarm_pending &= ~alarm_type_mask;
+			if (!alarm_ns->alarm_pending && !alarm_ns->wait_pending)
+				wake_unlock(&alarm_ns->alarm_wake_lock);
+		}
+		alarm_ns->alarm_enabled &= ~alarm_type_mask;
+		spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
 		break;
+
+	case ANDROID_ALARM_SET_OLD:
+	case ANDROID_ALARM_SET_AND_WAIT_OLD:
+		if (get_user(new_alarm_time.tv_sec, (int __user *)arg)) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		new_alarm_time.tv_nsec = 0;
+		goto from_old_alarm_set;
+
 	case ANDROID_ALARM_SET_AND_WAIT(0):
-		alarm_set(alarm_type, ts);
+	case ANDROID_ALARM_SET(0):
+		if (copy_from_user(&new_alarm_time, (void __user *)arg,
+		    sizeof(new_alarm_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+from_old_alarm_set:
+		spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+		pr_alarm(IO, "alarm %d set %ld.%09ld\n", alarm_type,
+			new_alarm_time.tv_sec, new_alarm_time.tv_nsec);
+		alarm_ns->alarm_enabled |= alarm_type_mask;
+		devalarm_start(&alarm_ns->alarms[alarm_type],
+			timespec_to_ktime(new_alarm_time));
+		spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
+		if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_SET_AND_WAIT(0)
+		    && cmd != ANDROID_ALARM_SET_AND_WAIT_OLD)
+			break;
 		/* fall though */
 	case ANDROID_ALARM_WAIT:
-		rv = alarm_wait();
+		spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+		pr_alarm(IO, "alarm wait\n");
+		if (!alarm_ns->alarm_pending && alarm_ns->wait_pending) {
+			wake_unlock(&alarm_ns->alarm_wake_lock);
+			alarm_ns->wait_pending = 0;
+		}
+		spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
+		rv = wait_event_interruptible(alarm_ns->alarm_wait_queue,
+					      alarm_ns->alarm_pending);
+		if (rv)
+			goto err1;
+		spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+		rv = alarm_ns->alarm_pending;
+		alarm_ns->wait_pending = 1;
+		alarm_ns->alarm_pending = 0;
+		spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
 		break;
 	case ANDROID_ALARM_SET_RTC:
-		rv = alarm_set_rtc(ts);
+		if (copy_from_user(&new_rtc_time, (void __user *)arg,
+		    sizeof(new_rtc_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		rtc_time_to_tm(new_rtc_time.tv_sec, &new_rtc_tm);
+		rtc_dev = alarmtimer_get_rtcdev();
+		rv = do_settimeofday(&new_rtc_time);
+		if (rv < 0)
+			goto err1;
+		if (rtc_dev)
+			rv = rtc_set_time(rtc_dev, &new_rtc_tm);
+		update_alarm_time_change(alarm_ns);
+#ifdef CONFIG_DEV_NS
+		propagate_alarm_time_change();
+#endif
+		if (rv < 0)
+			goto err1;
 		break;
 	case ANDROID_ALARM_GET_TIME(0):
-		rv = alarm_get_time(alarm_type, ts);
+		switch (alarm_type) {
+		case ANDROID_ALARM_RTC_WAKEUP:
+		case ANDROID_ALARM_RTC:
+			getnstimeofday(&tmp_time);
+			break;
+		case ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP:
+		case ANDROID_ALARM_ELAPSED_REALTIME:
+			get_monotonic_boottime(&tmp_time);
+			break;
+		case ANDROID_ALARM_TYPE_COUNT:
+		case ANDROID_ALARM_SYSTEMTIME:
+			ktime_get_ts(&tmp_time);
+			break;
+		}
+		if (copy_to_user((void __user *)arg, &tmp_time,
+		    sizeof(tmp_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
 		break;
 
 	default:
 		rv = -EINVAL;
+		goto err1;
 	}
+err1:
+	if (!opened)
+		put_alarm_ns(alarm_ns);
 	return rv;
 }
 
-static long alarm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-
-	struct timespec ts;
-	int rv;
-
-	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
-	case ANDROID_ALARM_SET_AND_WAIT(0):
-	case ANDROID_ALARM_SET(0):
-	case ANDROID_ALARM_SET_RTC:
-		if (copy_from_user(&ts, (void __user *)arg, sizeof(ts)))
-			return -EFAULT;
-		break;
-	}
-
-	rv = alarm_do_ioctl(file, cmd, &ts);
-	if (rv)
-		return rv;
-
-	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
-	case ANDROID_ALARM_GET_TIME(0):
-		if (copy_to_user((void __user *)arg, &ts, sizeof(ts)))
-			return -EFAULT;
-		break;
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_COMPAT
-static long alarm_compat_ioctl(struct file *file, unsigned int cmd,
-							unsigned long arg)
-{
-
-	struct timespec ts;
-	int rv;
-
-	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
-	case ANDROID_ALARM_SET_AND_WAIT_COMPAT(0):
-	case ANDROID_ALARM_SET_COMPAT(0):
-	case ANDROID_ALARM_SET_RTC_COMPAT:
-		if (compat_get_timespec(&ts, (void __user *)arg))
-			return -EFAULT;
-		/* fall through */
-	case ANDROID_ALARM_GET_TIME_COMPAT(0):
-		cmd = ANDROID_ALARM_COMPAT_TO_NORM(cmd);
-		break;
-	}
-
-	rv = alarm_do_ioctl(file, cmd, &ts);
-	if (rv)
-		return rv;
-
-	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
-	case ANDROID_ALARM_GET_TIME(0): /* NOTE: we modified cmd above */
-		if (compat_put_timespec(&ts, (void __user *)arg))
-			return -EFAULT;
-		break;
-	}
-
-	return 0;
-}
-#endif
-
 static int alarm_open(struct inode *inode, struct file *file)
 {
 	file->private_data = NULL;
@@ -324,34 +384,44 @@ static int alarm_release(struct inode *inode, struct file *file)
 {
 	int i;
 	unsigned long flags;
+	struct alarm_dev_ns *alarm_ns;
+
+	//alarm_ns = get_alarm_ns_cur();
+    if(file->private_data != 0){
+        alarm_ns = file->private_data;
+    }else{
+        return 0;
+    }
 
-	spin_lock_irqsave(&alarm_slock, flags);
-	if (file->private_data) {
+	spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+	if (file->private_data != 0) {
 		for (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++) {
 			uint32_t alarm_type_mask = 1U << i;
-
-			if (alarm_enabled & alarm_type_mask) {
-				alarm_dbg(INFO,
-					  "%s: clear alarm, pending %d\n",
-					  __func__,
-					  !!(alarm_pending & alarm_type_mask));
-				alarm_enabled &= ~alarm_type_mask;
+			if (alarm_ns->alarm_enabled & alarm_type_mask) {
+				pr_alarm(INFO, "alarm_release: clear alarm, "
+					"pending %d\n",
+					!!(alarm_ns->alarm_pending &
+					   alarm_type_mask));
+				alarm_ns->alarm_enabled &= ~alarm_type_mask;
 			}
-			spin_unlock_irqrestore(&alarm_slock, flags);
-			devalarm_cancel(&alarms[i]);
-			spin_lock_irqsave(&alarm_slock, flags);
+			spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
+			devalarm_cancel(&alarm_ns->alarms[i]);
+			spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
 		}
-		if (alarm_pending | wait_pending) {
-			if (alarm_pending)
-				alarm_dbg(INFO, "%s: clear pending alarms %x\n",
-					  __func__, alarm_pending);
-			__pm_relax(&alarm_wake_lock);
-			wait_pending = 0;
-			alarm_pending = 0;
+		if (alarm_ns->alarm_pending | alarm_ns->wait_pending) {
+			if (alarm_ns->alarm_pending)
+				pr_alarm(INFO, "alarm_release: clear "
+					 "pending alarms %x\n",
+					 alarm_ns->alarm_pending);
+			wake_unlock(&alarm_ns->alarm_wake_lock);
+			alarm_ns->wait_pending = 0;
+			alarm_ns->alarm_pending = 0;
 		}
-		alarm_opened = 0;
+		alarm_ns->alarm_opened = 0;
+		put_alarm_ns(alarm_ns);  /* drop reference from open time */
 	}
-	spin_unlock_irqrestore(&alarm_slock, flags);
+	spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
+	put_alarm_ns(alarm_ns);
 	return 0;
 }
 
@@ -359,18 +429,21 @@ static void devalarm_triggered(struct devalarm *alarm)
 {
 	unsigned long flags;
 	uint32_t alarm_type_mask = 1U << alarm->type;
-
-	alarm_dbg(INT, "%s: type %d\n", __func__, alarm->type);
-	spin_lock_irqsave(&alarm_slock, flags);
-	if (alarm_enabled & alarm_type_mask) {
-		__pm_wakeup_event(&alarm_wake_lock, 5000); /* 5secs */
-		alarm_enabled &= ~alarm_type_mask;
-		alarm_pending |= alarm_type_mask;
-		wake_up(&alarm_wait_queue);
+	struct alarm_dev_ns *alarm_ns = alarm->alarm_ns;
+
+	pr_alarm(INT, "devalarm_triggered type %d\n", alarm->type);
+	spin_lock_irqsave(&alarm_ns->alarm_slock, flags);
+	if (alarm_ns->alarm_enabled & alarm_type_mask) {
+		//wake_lock_timeout(&alarm_ns->alarm_wake_lock, 5 * HZ);
+		__pm_wakeup_event(&(alarm_ns->alarm_wake_lock).ws, 5000);
+		alarm_ns->alarm_enabled &= ~alarm_type_mask;
+		alarm_ns->alarm_pending |= alarm_type_mask;
+		wake_up(&alarm_ns->alarm_wait_queue);
 	}
-	spin_unlock_irqrestore(&alarm_slock, flags);
+	spin_unlock_irqrestore(&alarm_ns->alarm_slock, flags);
 }
 
+
 static enum hrtimer_restart devalarm_hrthandler(struct hrtimer *hrt)
 {
 	struct devalarm *devalrm = container_of(hrt, struct devalarm, u.hrt);
@@ -392,14 +465,8 @@ static enum alarmtimer_restart devalarm_alarmhandler(struct alarm *alrm,
 static const struct file_operations alarm_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = alarm_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = alarm_ioctl,
-#endif
 	.open = alarm_open,
 	.release = alarm_release,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = alarm_compat_ioctl,
-#endif
 };
 
 static struct miscdevice alarm_device = {
@@ -408,15 +475,12 @@ static struct miscdevice alarm_device = {
 	.fops = &alarm_fops,
 };
 
-static int __init alarm_dev_init(void)
+static void devalarm_alarms_init(struct devalarm *alarms)
 {
-	int err;
+	struct alarm_dev_ns *alarm_ns =
+		container_of(alarms, struct alarm_dev_ns, alarms[0]);
 	int i;
 
-	err = misc_register(&alarm_device);
-	if (err)
-		return err;
-
 	alarm_init(&alarms[ANDROID_ALARM_RTC_WAKEUP].u.alrm,
 			ALARM_REALTIME, devalarm_alarmhandler);
 	hrtimer_init(&alarms[ANDROID_ALARM_RTC].u.hrt,
@@ -430,20 +494,44 @@ static int __init alarm_dev_init(void)
 
 	for (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++) {
 		alarms[i].type = i;
+		alarms[i].alarm_ns = alarm_ns;
 		if (!is_wakeup(i))
 			alarms[i].u.hrt.function = devalarm_hrthandler;
 	}
 
-	wakeup_source_init(&alarm_wake_lock, "alarm");
+}
+
+static int __init alarm_dev_init(void)
+{
+	int err;
+
+	err = misc_register(&alarm_device);
+	if (err)
+		return err;
+
+#ifdef CONFIG_DEV_NS
+	err = DEV_NS_REGISTER(alarm, "alarm");
+	if (err < 0) {
+		misc_deregister(&alarm_device);
+		return err;
+	}
+    pr_alarm(INFO, "alarm_dev_init finished.");
+#else
+	alarm_ns_initialize(&init_alarm_ns);
+#endif
 	return 0;
 }
 
 static void  __exit alarm_dev_exit(void)
 {
 	misc_deregister(&alarm_device);
-	wakeup_source_trash(&alarm_wake_lock);
+#ifdef CONFIG_DEV_NS
+	DEV_NS_UNREGISTER(alarm);
+#else
+	alarm_ns_destroy(&init_alarm_ns);
+#endif
 }
 
 module_init(alarm_dev_init);
 module_exit(alarm_dev_exit);
-MODULE_LICENSE("GPL");
+
diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index ce21274..8255e74 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -36,6 +36,7 @@
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
+#include <linux/dev_namespace.h>
 #include <linux/pid_namespace.h>
 
 #include "binder.h"
@@ -45,17 +46,77 @@ static DEFINE_MUTEX(binder_main_lock);
 static DEFINE_MUTEX(binder_deferred_lock);
 static DEFINE_MUTEX(binder_mmap_lock);
 
-static HLIST_HEAD(binder_procs);
+//static HLIST_HEAD(binder_procs);
 static HLIST_HEAD(binder_deferred_list);
-static HLIST_HEAD(binder_dead_nodes);
+//static HLIST_HEAD(binder_dead_nodes);
 
 static struct dentry *binder_debugfs_dir_entry_root;
 static struct dentry *binder_debugfs_dir_entry_proc;
-static struct binder_node *binder_context_mgr_node;
-static kuid_t binder_context_mgr_uid = INVALID_UID;
-static int binder_last_id;
+//static struct binder_node *binder_context_mgr_node;
+//static kuid_t binder_context_mgr_uid = INVALID_UID;
+//static int binder_last_id;
 static struct workqueue_struct *binder_deferred_workqueue;
 
+struct binder_dev_ns {
+	struct binder_node	*context_mgr_node;
+	kuid_t			context_mgr_uid;
+	int			last_id;
+
+	struct hlist_head	procs;
+	struct hlist_head	dead_nodes;
+
+	struct dev_ns_info	dev_ns_info;
+};
+
+static void binder_ns_initialize(struct binder_dev_ns *binder_ns)
+{
+	INIT_HLIST_HEAD(&binder_ns->procs);
+	INIT_HLIST_HEAD(&binder_ns->dead_nodes);
+
+	binder_ns->context_mgr_uid = INVALID_UID;
+}
+
+
+#ifdef CONFIG_DEV_NS
+
+/* binder_ns_id, get_binder_ns(), get_binder_ns_cur(), put_binder_ns() */
+DEFINE_DEV_NS_INFO(binder)
+
+static struct dev_ns_info *binder_ns_create(struct dev_namespace *dev_ns)
+{
+	struct binder_dev_ns *binder_ns;
+
+	binder_ns = kzalloc(sizeof(*binder_ns), GFP_KERNEL);
+	if (!binder_ns)
+		return ERR_PTR(-ENOMEM);
+
+	binder_ns_initialize(binder_ns);
+
+	return &binder_ns->dev_ns_info;
+}
+
+static void binder_ns_release(struct dev_ns_info *dev_ns_info)
+{
+	struct binder_dev_ns *binder_ns;
+
+	binder_ns = container_of(dev_ns_info, struct binder_dev_ns,
+				 dev_ns_info);
+	kfree(binder_ns);
+}
+
+static struct dev_ns_ops binder_ns_ops = {
+	.create = binder_ns_create,
+	.release = binder_ns_release,
+};
+
+#else
+
+/* init_binder_ns, get_binder_ns_cur(), put_binder_ns() */
+DEFINE_DEV_NS_INIT(binder)
+
+#endif /* CONFIG_DEVICE_NS */
+
+
 #define BINDER_DEBUG_ENTRY(name) \
 static int binder_##name##_open(struct inode *inode, struct file *file) \
 { \
@@ -303,6 +364,8 @@ struct binder_proc {
 	void *buffer;
 	ptrdiff_t user_buffer_offset;
 
+    struct binder_dev_ns *binder_ns;
+
 	struct list_head buffers;
 	struct rb_root free_buffers;
 	struct rb_root allocated_buffers;
@@ -904,7 +967,8 @@ static struct binder_node *binder_new_node(struct binder_proc *proc,
 	binder_stats_created(BINDER_STAT_NODE);
 	rb_link_node(&node->rb_node, parent, p);
 	rb_insert_color(&node->rb_node, &proc->nodes);
-	node->debug_id = ++binder_last_id;
+//	node->debug_id = ++binder_last_id;
+	node->debug_id = ++proc->binder_ns->last_id;
 	node->proc = proc;
 	node->ptr = ptr;
 	node->cookie = cookie;
@@ -925,7 +989,8 @@ static int binder_inc_node(struct binder_node *node, int strong, int internal,
 		if (internal) {
 			if (target_list == NULL &&
 			    node->internal_strong_refs == 0 &&
-			    !(node == binder_context_mgr_node &&
+//			    !(node == binder_context_mgr_node &&
+			    !(node == node->proc->binder_ns->context_mgr_node &&
 			    node->has_strong_ref)) {
 				pr_err("invalid inc strong node for %d\n",
 					node->debug_id);
@@ -1039,13 +1104,15 @@ static struct binder_ref *binder_get_ref_for_node(struct binder_proc *proc,
 	if (new_ref == NULL)
 		return NULL;
 	binder_stats_created(BINDER_STAT_REF);
-	new_ref->debug_id = ++binder_last_id;
+//	new_ref->debug_id = ++binder_last_id;
+	new_ref->debug_id = ++proc->binder_ns->last_id;
 	new_ref->proc = proc;
 	new_ref->node = node;
 	rb_link_node(&new_ref->rb_node_node, parent, p);
 	rb_insert_color(&new_ref->rb_node_node, &proc->refs_by_node);
 
-	new_ref->desc = (node == binder_context_mgr_node) ? 0 : 1;
+	//new_ref->desc = (node == binder_context_mgr_node) ? 0 : 1;
+	new_ref->desc = (node == proc->binder_ns->context_mgr_node) ? 0 : 1;
 	for (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {
 		ref = rb_entry(n, struct binder_ref, rb_node_desc);
 		if (ref->desc > new_ref->desc)
@@ -1385,7 +1452,8 @@ static void binder_transaction(struct binder_proc *proc,
 			}
 			target_node = ref->node;
 		} else {
-			target_node = binder_context_mgr_node;
+//			target_node = binder_context_mgr_node;
+			target_node = proc->binder_ns->context_mgr_node;
 			if (target_node == NULL) {
 				return_error = BR_DEAD_REPLY;
 				goto err_no_context_mgr_node;
@@ -1442,7 +1510,8 @@ static void binder_transaction(struct binder_proc *proc,
 	}
 	binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);
 
-	t->debug_id = ++binder_last_id;
+//	t->debug_id = ++binder_last_id;
+	t->debug_id = ++proc->binder_ns->last_id;
 	e->debug_id = t->debug_id;
 
 	if (reply)
@@ -1764,10 +1833,12 @@ static int binder_thread_write(struct binder_proc *proc,
 			if (get_user(target, (uint32_t __user *)ptr))
 				return -EFAULT;
 			ptr += sizeof(uint32_t);
-			if (target == 0 && binder_context_mgr_node &&
+//			if (target == 0 && binder_context_mgr_node &&
+			if (target == 0 && proc->binder_ns->context_mgr_node &&
 			    (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) {
 				ref = binder_get_ref_for_node(proc,
-					       binder_context_mgr_node);
+					       //binder_context_mgr_node);
+					       proc->binder_ns->context_mgr_node);
 				if (ref->desc != target) {
 					binder_user_error("%d:%d tried to acquire reference to desc 0, got %d instead\n",
 						proc->pid, thread->pid,
@@ -2678,32 +2749,32 @@ static int binder_ioctl_set_ctx_mgr(struct file *filp)
 	struct binder_proc *proc = filp->private_data;
 	kuid_t curr_euid = current_euid();
 
-	if (binder_context_mgr_node != NULL) {
+	if (proc->binder_ns->context_mgr_node != NULL) {
 		pr_err("BINDER_SET_CONTEXT_MGR already set\n");
 		ret = -EBUSY;
 		goto out;
 	}
-	if (uid_valid(binder_context_mgr_uid)) {
-		if (!uid_eq(binder_context_mgr_uid, curr_euid)) {
+	if (uid_valid(proc->binder_ns->context_mgr_uid)) {
+		if (!uid_eq(proc->binder_ns->context_mgr_uid, curr_euid)) {
 			pr_err("BINDER_SET_CONTEXT_MGR bad uid %d != %d\n",
 			       from_kuid(&init_user_ns, curr_euid),
 			       from_kuid(&init_user_ns,
-					binder_context_mgr_uid));
+					proc->binder_ns->context_mgr_uid));
 			ret = -EPERM;
 			goto out;
 		}
 	} else {
-		binder_context_mgr_uid = curr_euid;
+		proc->binder_ns->context_mgr_uid = curr_euid;
 	}
-	binder_context_mgr_node = binder_new_node(proc, 0, 0);
-	if (binder_context_mgr_node == NULL) {
+	proc->binder_ns->context_mgr_node = binder_new_node(proc, 0, 0);
+	if (proc->binder_ns->context_mgr_node == NULL) {
 		ret = -ENOMEM;
 		goto out;
 	}
-	binder_context_mgr_node->local_weak_refs++;
-	binder_context_mgr_node->local_strong_refs++;
-	binder_context_mgr_node->has_strong_ref = 1;
-	binder_context_mgr_node->has_weak_ref = 1;
+    proc->binder_ns->context_mgr_node->local_weak_refs++;
+    proc->binder_ns->context_mgr_node->local_strong_refs++;
+    proc->binder_ns->context_mgr_node->has_strong_ref = 1;
+    proc->binder_ns->context_mgr_node->has_weak_ref = 1;
 out:
 	return ret;
 }
@@ -2924,13 +2995,22 @@ err_bad_arg:
 static int binder_open(struct inode *nodp, struct file *filp)
 {
 	struct binder_proc *proc;
+    struct binder_dev_ns *binder_ns;
 
 	binder_debug(BINDER_DEBUG_OPEN_CLOSE, "binder_open: %d:%d\n",
 		     current->group_leader->pid, current->pid);
 
+    binder_ns = get_binder_ns_cur();
+    if(!binder_ns)
+        return -ENOMEM;
+
 	proc = kzalloc(sizeof(*proc), GFP_KERNEL);
-	if (proc == NULL)
+	if (proc == NULL){
+        put_binder_ns(binder_ns);
 		return -ENOMEM;
+    }
+
+    proc->binder_ns = binder_ns;
 	get_task_struct(current);
 	proc->tsk = current;
 	INIT_LIST_HEAD(&proc->todo);
@@ -2940,7 +3020,7 @@ static int binder_open(struct inode *nodp, struct file *filp)
 	binder_lock(__func__);
 
 	binder_stats_created(BINDER_STAT_PROC);
-	hlist_add_head(&proc->proc_node, &binder_procs);
+	hlist_add_head(&proc->proc_node, &binder_ns->procs);
 	proc->pid = current->group_leader->pid;
 	INIT_LIST_HEAD(&proc->delivered_death);
 	filp->private_data = proc;
@@ -3013,10 +3093,12 @@ static int binder_node_release(struct binder_node *node, int refs)
 		return refs;
 	}
 
+    struct binder_proc *proc;
+    proc = node->proc;
 	node->proc = NULL;
 	node->local_strong_refs = 0;
 	node->local_weak_refs = 0;
-	hlist_add_head(&node->dead_node, &binder_dead_nodes);
+	hlist_add_head(&node->dead_node, &proc->binder_ns->dead_nodes);
 
 	hlist_for_each_entry(ref, &node->refs, node_entry) {
 		refs++;
@@ -3054,11 +3136,12 @@ static void binder_deferred_release(struct binder_proc *proc)
 
 	hlist_del(&proc->proc_node);
 
-	if (binder_context_mgr_node && binder_context_mgr_node->proc == proc) {
+	if (proc->binder_ns->context_mgr_node && 
+            proc->binder_ns->context_mgr_node->proc == proc) {
 		binder_debug(BINDER_DEBUG_DEAD_BINDER,
 			     "%s: %d context_mgr_node gone\n",
 			     __func__, proc->pid);
-		binder_context_mgr_node = NULL;
+		proc->binder_ns->context_mgr_node = NULL;
 	}
 
 	threads = 0;
@@ -3144,6 +3227,7 @@ static void binder_deferred_release(struct binder_proc *proc)
 		     __func__, proc->pid, threads, nodes, incoming_refs,
 		     outgoing_refs, active_transactions, buffers, page_count);
 
+    put_binder_ns(proc->binder_ns);
 	kfree(proc);
 }
 
@@ -3515,62 +3599,123 @@ static void print_binder_proc_stats(struct seq_file *m,
 }
 
 
+static void __binder_state_show(struct dev_ns_info *dev_ns_info, void *data)
+ {
+	struct binder_dev_ns *binder_ns;
+	struct seq_file *m = data;
+ 	struct binder_proc *proc;
+ 	struct hlist_node *pos;
+ 	struct binder_node *node;
+	char str[64];
+ 
+	binder_ns = container_of(dev_ns_info, struct binder_dev_ns,
+				 dev_ns_info);
+ 
+	snprintf(str, sizeof(str),
+		 "binder state (0x%p):\n", dev_ns_info->dev_ns);
+	seq_puts(m, str);
+ 
+	if (!hlist_empty(&binder_ns->dead_nodes))
+ 		seq_puts(m, "dead nodes:\n");
+	hlist_for_each_entry(node, &binder_ns->dead_nodes, dead_node)
+ 		print_binder_node(m, node);
+	hlist_for_each_entry(proc, &binder_ns->procs, proc_node)
+ 		print_binder_proc(m, proc, 1);
+}
+
 static int binder_state_show(struct seq_file *m, void *unused)
 {
-	struct binder_proc *proc;
-	struct binder_node *node;
 	int do_lock = !binder_debug_no_lock;
 
 	if (do_lock)
 		binder_lock(__func__);
 
-	seq_puts(m, "binder state:\n");
-
-	if (!hlist_empty(&binder_dead_nodes))
-		seq_puts(m, "dead nodes:\n");
-	hlist_for_each_entry(node, &binder_dead_nodes, dead_node)
-		print_binder_node(m, node);
+#ifdef CONFIG_DEV_NS
+	loop_dev_ns_info(binder_ns_id, m, __binder_state_show);
+#else
+	__binder_state_show(&init_binder_ns.dev_ns_info, m);
+#endif
 
-	hlist_for_each_entry(proc, &binder_procs, proc_node)
-		print_binder_proc(m, proc, 1);
-	if (do_lock)
-		binder_unlock(__func__);
-	return 0;
+ 	if (do_lock)
+ 		binder_unlock(__func__);
+ 	return 0;
 }
 
-static int binder_stats_show(struct seq_file *m, void *unused)
+static void __binder_stats_show(struct dev_ns_info *dev_ns_info, void *data)
 {
+	struct binder_dev_ns *binder_ns;
+	struct seq_file *m = data;
 	struct binder_proc *proc;
-	int do_lock = !binder_debug_no_lock;
+	struct hlist_node *pos;
+	char str[64];
 
-	if (do_lock)
-		binder_lock(__func__);
+	binder_ns = container_of(dev_ns_info, struct binder_dev_ns,
+				 dev_ns_info);
 
-	seq_puts(m, "binder stats:\n");
+	snprintf(str, sizeof(str),
+		 "binder stats (0x%p):\n", dev_ns_info->dev_ns);
+	seq_puts(m, str);
 
 	print_binder_stats(m, "", &binder_stats);
-
-	hlist_for_each_entry(proc, &binder_procs, proc_node)
+	hlist_for_each_entry(proc,  &binder_ns->procs, proc_node)
 		print_binder_proc_stats(m, proc);
-	if (do_lock)
-		binder_unlock(__func__);
-	return 0;
 }
 
-static int binder_transactions_show(struct seq_file *m, void *unused)
+static int binder_stats_show(struct seq_file *m, void *unused)
 {
+ 	int do_lock = !binder_debug_no_lock;
+ 
+ 	if (do_lock)
+ 		binder_lock(__func__);
+ 
+#ifdef CONFIG_DEV_NS
+	loop_dev_ns_info(binder_ns_id, m, __binder_stats_show);
+#else
+	__binder_stats_show(&init_binder_ns.dev_ns_info, m);
+#endif
+ 
+ 	if (do_lock)
+ 		binder_unlock(__func__);
+ 	return 0;
+}
+
+
+static void __binder_transaction_show(struct dev_ns_info *dev_ns_info,
+				      void *data)
+{
+	struct binder_dev_ns *binder_ns;
+	struct seq_file *m = data;
 	struct binder_proc *proc;
-	int do_lock = !binder_debug_no_lock;
+	struct hlist_node *pos;
+	char str[64];
 
-	if (do_lock)
-		binder_lock(__func__);
+	binder_ns = container_of(dev_ns_info, struct binder_dev_ns,
+				 dev_ns_info);
+
+	snprintf(str, sizeof(str),
+		 "binder transactions (0x%p):\n", dev_ns_info->dev_ns);
+	seq_puts(m, str);
 
-	seq_puts(m, "binder transactions:\n");
-	hlist_for_each_entry(proc, &binder_procs, proc_node)
+	hlist_for_each_entry(proc, &binder_ns->procs, proc_node)
 		print_binder_proc(m, proc, 0);
-	if (do_lock)
-		binder_unlock(__func__);
-	return 0;
+}
+
+static int binder_transactions_show(struct seq_file *m, void *unused)
+{
+ 	int do_lock = !binder_debug_no_lock;
+ 
+ 	if (do_lock)
+ 		binder_lock(__func__);
+ 
+#ifdef CONFIG_DEV_NS
+	loop_dev_ns_info(binder_ns_id, m, __binder_transaction_show);
+#else
+	__binder_transaction_show(&init_binder_ns.dev_ns_info, m);
+#endif
+
+ 	if (do_lock)
+ 		binder_unlock(__func__);
+ 	return 0;
 }
 
 static int binder_proc_show(struct seq_file *m, void *unused)
@@ -3642,6 +3787,16 @@ static int __init binder_init(void)
 	if (!binder_deferred_workqueue)
 		return -ENOMEM;
 
+#ifdef CONFIG_DEV_NS
+	ret = DEV_NS_REGISTER(binder, "binder");
+	if (ret < 0) {
+		destroy_workqueue(binder_deferred_workqueue);
+		return ret;
+	}
+#else
+	binder_ns_initialize(&init_binder_ns);
+#endif
+
 	binder_debugfs_dir_entry_root = debugfs_create_dir("binder", NULL);
 	if (binder_debugfs_dir_entry_root)
 		binder_debugfs_dir_entry_proc = debugfs_create_dir("proc",
diff --git a/fs/Kconfig b/fs/Kconfig
index 664991a..1481093 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -210,6 +210,7 @@ source "fs/ufs/Kconfig"
 source "fs/exofs/Kconfig"
 source "fs/f2fs/Kconfig"
 source "fs/efivarfs/Kconfig"
+source "fs/aufs/Kconfig"
 
 endif # MISC_FILESYSTEMS
 
diff --git a/fs/Makefile b/fs/Makefile
index da0bbb4..c8bc724 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -126,3 +126,4 @@ obj-y				+= exofs/ # Multiple modules
 obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
 obj-$(CONFIG_EFIVAR_FS)		+= efivarfs/
+obj-$(CONFIG_AUFS_FS)           += aufs/
diff --git a/fs/buffer.c b/fs/buffer.c
index 20805db..363569f 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2450,7 +2450,7 @@ int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 	 * Update file times before taking page lock. We may end up failing the
 	 * fault so this update may be superfluous but who really cares...
 	 */
-	file_update_time(vma->vm_file);
+	vma_file_update_time(vma);
 
 	ret = __block_page_mkwrite(vma, vmf, get_block);
 	sb_end_pagefault(sb);
diff --git a/fs/dcache.c b/fs/dcache.c
index 5bc72b0..909aef4 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -1020,7 +1020,7 @@ enum d_walk_ret {
  *
  * The @enter() and @finish() callbacks are called with d_lock held.
  */
-static void d_walk(struct dentry *parent, void *data,
+void d_walk(struct dentry *parent, void *data,
 		   enum d_walk_ret (*enter)(void *, struct dentry *),
 		   void (*finish)(void *))
 {
@@ -1124,6 +1124,7 @@ rename_retry:
 	seq = 1;
 	goto again;
 }
+EXPORT_SYMBOL(d_walk);
 
 /*
  * Search for at least 1 mount point in the dentry's subdirs.
diff --git a/fs/file_table.c b/fs/file_table.c
index 3f85411..00e9dcf 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -147,6 +147,7 @@ over:
 	}
 	return ERR_PTR(-ENFILE);
 }
+EXPORT_SYMBOL(get_empty_filp);
 
 /**
  * alloc_file - allocate and initialize a 'struct file'
@@ -308,6 +309,7 @@ void put_filp(struct file *file)
 		file_free(file);
 	}
 }
+EXPORT_SYMBOL(put_filp);
 
 void __init files_init(unsigned long mempages)
 { 
diff --git a/fs/inode.c b/fs/inode.c
index 26753ba..c8df03d 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -57,6 +57,7 @@ static struct hlist_head *inode_hashtable __read_mostly;
 static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);
 
 __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);
+EXPORT_SYMBOL(inode_sb_list_lock);
 
 /*
  * Empty aops. Can be used for the cases where the user does not
@@ -1497,7 +1498,7 @@ static int relatime_need_update(struct vfsmount *mnt, struct inode *inode,
  * This does the actual work of updating an inodes time or version.  Must have
  * had called mnt_want_write() before calling this.
  */
-static int update_time(struct inode *inode, struct timespec *time, int flags)
+int update_time(struct inode *inode, struct timespec *time, int flags)
 {
 	if (inode->i_op->update_time)
 		return inode->i_op->update_time(inode, time, flags);
@@ -1513,6 +1514,7 @@ static int update_time(struct inode *inode, struct timespec *time, int flags)
 	mark_inode_dirty_sync(inode);
 	return 0;
 }
+EXPORT_SYMBOL(update_time);
 
 /**
  *	touch_atime	-	update the access time
diff --git a/fs/namespace.c b/fs/namespace.c
index 5b66b2b..68ff4e4 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -454,6 +454,7 @@ void __mnt_drop_write(struct vfsmount *mnt)
 	mnt_dec_writers(real_mount(mnt));
 	preempt_enable();
 }
+EXPORT_SYMBOL_GPL(__mnt_drop_write);
 
 /**
  * mnt_drop_write - give up write access to a mount
@@ -1727,6 +1728,7 @@ int iterate_mounts(int (*f)(struct vfsmount *, void *), void *arg,
 	}
 	return 0;
 }
+EXPORT_SYMBOL(iterate_mounts);
 
 static void cleanup_group_ids(struct mount *mnt, struct mount *end)
 {
diff --git a/fs/notify/group.c b/fs/notify/group.c
index d16b62c..06ca6bc 100644
--- a/fs/notify/group.c
+++ b/fs/notify/group.c
@@ -22,6 +22,7 @@
 #include <linux/srcu.h>
 #include <linux/rculist.h>
 #include <linux/wait.h>
+#include <linux/module.h>
 
 #include <linux/fsnotify_backend.h>
 #include "fsnotify.h"
@@ -72,6 +73,7 @@ void fsnotify_get_group(struct fsnotify_group *group)
 {
 	atomic_inc(&group->refcnt);
 }
+EXPORT_SYMBOL(fsnotify_get_group);
 
 /*
  * Drop a reference to a group.  Free it if it's through.
@@ -81,6 +83,7 @@ void fsnotify_put_group(struct fsnotify_group *group)
 	if (atomic_dec_and_test(&group->refcnt))
 		fsnotify_final_destroy_group(group);
 }
+EXPORT_SYMBOL(fsnotify_put_group);
 
 /*
  * Create a new fsnotify_group and hold a reference for the group returned.
@@ -109,6 +112,7 @@ struct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *ops)
 
 	return group;
 }
+EXPORT_SYMBOL(fsnotify_alloc_group);
 
 int fsnotify_fasync(int fd, struct file *file, int on)
 {
diff --git a/fs/notify/mark.c b/fs/notify/mark.c
index 34c38fa..d40cf58 100644
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -109,6 +109,7 @@ void fsnotify_put_mark(struct fsnotify_mark *mark)
 		mark->free_mark(mark);
 	}
 }
+EXPORT_SYMBOL(fsnotify_put_mark);
 
 /*
  * Any time a mark is getting freed we end up here.
@@ -191,6 +192,7 @@ void fsnotify_destroy_mark(struct fsnotify_mark *mark,
 	fsnotify_destroy_mark_locked(mark, group);
 	mutex_unlock(&group->mark_mutex);
 }
+EXPORT_SYMBOL(fsnotify_destroy_mark);
 
 void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)
 {
@@ -311,6 +313,7 @@ err:
 
 	return ret;
 }
+EXPORT_SYMBOL(fsnotify_add_mark);
 
 int fsnotify_add_mark(struct fsnotify_mark *mark, struct fsnotify_group *group,
 		      struct inode *inode, struct vfsmount *mnt, int allow_dups)
@@ -372,6 +375,7 @@ void fsnotify_init_mark(struct fsnotify_mark *mark,
 	atomic_set(&mark->refcnt, 1);
 	mark->free_mark = free_mark;
 }
+EXPORT_SYMBOL(fsnotify_init_mark);
 
 static int fsnotify_mark_destroy(void *ignored)
 {
diff --git a/fs/open.c b/fs/open.c
index de92c13..e3384c0 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -62,6 +62,7 @@ int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
 	mutex_unlock(&dentry->d_inode->i_mutex);
 	return ret;
 }
+EXPORT_SYMBOL(do_truncate);
 
 long vfs_truncate(struct path *path, loff_t length)
 {
@@ -298,6 +299,7 @@ int do_fallocate(struct file *file, int mode, loff_t offset, loff_t len)
 	sb_end_write(inode->i_sb);
 	return ret;
 }
+EXPORT_SYMBOL(do_fallocate);
 
 SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 {
@@ -663,6 +665,7 @@ int open_check_o_direct(struct file *f)
 	}
 	return 0;
 }
+EXPORT_SYMBOL(open_check_o_direct);
 
 static int do_dentry_open(struct file *f,
 			  int (*open)(struct inode *, struct file *),
diff --git a/fs/proc/base.c b/fs/proc/base.c
index e722a6f..f0c46d6 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1772,7 +1772,7 @@ static int proc_map_files_get_link(struct dentry *dentry, struct path *path)
 	down_read(&mm->mmap_sem);
 	vma = find_exact_vma(mm, vm_start, vm_end);
 	if (vma && vma->vm_file) {
-		*path = vma->vm_file->f_path;
+		*path = vma_pr_or_file(vma)->f_path;
 		path_get(path);
 		rc = 0;
 	}
diff --git a/fs/proc/nommu.c b/fs/proc/nommu.c
index d4a3574..1397181 100644
--- a/fs/proc/nommu.c
+++ b/fs/proc/nommu.c
@@ -45,7 +45,10 @@ static int nommu_region_show(struct seq_file *m, struct vm_region *region)
 	file = region->vm_file;
 
 	if (file) {
-		struct inode *inode = file_inode(region->vm_file);
+		struct inode *inode;
+
+		file = vmr_pr_or_file(region);
+		inode = file_inode(file);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 	}
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 4e0388c..fc429e7 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -276,7 +276,10 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 	const char *name = NULL;
 
 	if (file) {
-		struct inode *inode = file_inode(vma->vm_file);
+		struct inode *inode;
+
+		file = vma_pr_or_file(vma);
+		inode = file_inode(file);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
@@ -1440,7 +1443,7 @@ static int show_numa_map(struct seq_file *m, void *v, int is_pid)
 	struct proc_maps_private *proc_priv = &numa_priv->proc_maps;
 	struct vm_area_struct *vma = v;
 	struct numa_maps *md = &numa_priv->md;
-	struct file *file = vma->vm_file;
+	struct file *file = vma_pr_or_file(vma);
 	struct mm_struct *mm = vma->vm_mm;
 	struct mm_walk walk = {};
 	struct mempolicy *pol;
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index 599ec2e..de6cd6e 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -160,7 +160,10 @@ static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,
 	file = vma->vm_file;
 
 	if (file) {
-		struct inode *inode = file_inode(vma->vm_file);
+		struct inode *inode;
+
+		file = vma_pr_or_file(file);
+		inode = file_inode(file);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;
diff --git a/fs/splice.c b/fs/splice.c
index 75c6058..c14f60e 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -1114,8 +1114,8 @@ EXPORT_SYMBOL(generic_splice_sendpage);
 /*
  * Attempt to initiate a splice from pipe to file.
  */
-static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
-			   loff_t *ppos, size_t len, unsigned int flags)
+long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
+		    loff_t *ppos, size_t len, unsigned int flags)
 {
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *,
 				loff_t *, size_t, unsigned int);
@@ -1127,13 +1127,14 @@ static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
 
 	return splice_write(pipe, out, ppos, len, flags);
 }
+EXPORT_SYMBOL(do_splice_from);
 
 /*
  * Attempt to initiate a splice from a file to a pipe.
  */
-static long do_splice_to(struct file *in, loff_t *ppos,
-			 struct pipe_inode_info *pipe, size_t len,
-			 unsigned int flags)
+long do_splice_to(struct file *in, loff_t *ppos,
+		  struct pipe_inode_info *pipe, size_t len,
+		  unsigned int flags)
 {
 	ssize_t (*splice_read)(struct file *, loff_t *,
 			       struct pipe_inode_info *, size_t, unsigned int);
@@ -1153,6 +1154,7 @@ static long do_splice_to(struct file *in, loff_t *ppos,
 
 	return splice_read(in, ppos, pipe, len, flags);
 }
+EXPORT_SYMBOL(do_splice_to);
 
 /**
  * splice_direct_to_actor - splices data directly between two non-pipes
diff --git a/fs/xattr.c b/fs/xattr.c
index 64e83ef..bd71e53 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -207,6 +207,7 @@ vfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,
 	*xattr_value = value;
 	return error;
 }
+EXPORT_SYMBOL(vfs_getxattr_alloc);
 
 /* Compare an extended attribute value with the given value */
 int vfs_xattr_cmp(struct dentry *dentry, const char *xattr_name,
diff --git a/include/linux/dcache.h b/include/linux/dcache.h
index b2a2a08..d9a0d7d 100644
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -128,7 +128,7 @@ struct dentry {
 	 * d_child and d_rcu can share memory
 	 */
 	union {
-		struct list_head d_child;	/* child of parent list */
+	    struct list_head d_child;	/* child of parent list */
 	 	struct rcu_head d_rcu;
 	} d_u;
 	struct list_head d_subdirs;	/* our children */
diff --git a/include/linux/dev_namespace.h b/include/linux/dev_namespace.h
new file mode 100644
index 0000000..1809e6a
--- /dev/null
+++ b/include/linux/dev_namespace.h
@@ -0,0 +1,269 @@
+/*
+ * include/linux/dev_namespace.h
+ *
+ * Copyright (c) 2011-2013 Cellrox Ltd. Certain portions are copyrighted by
+ * Columbia University. This program is free software licensed under the GNU
+ * General Public License Version 2 (GPL 2). You can distribute it and/or
+ * modify it under the terms of the GPL 2.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GPL 2 license for more details.
+ * The full GPL 2 License is included in this distribution in the file called
+ * COPYING
+ *
+ * Cellrox can be contacted at oss@cellrox.com
+ */
+
+#ifndef _LINUX_DEV_NS_H
+#define _LINUX_DEV_NS_H
+
+#include <linux/pid_namespace.h>
+#include <linux/nsproxy.h>
+#include <linux/notifier.h>
+#include <linux/hardirq.h>
+#include <linux/err.h>
+
+#ifdef __KERNEL__
+
+#define DEV_NS_TAG_LEN 4
+#define DEV_NS_DESC_MAX 16
+
+struct dev_namespace;
+struct dev_ns_info;
+
+struct dev_namespace {
+
+	bool active;
+	atomic_t count;
+	pid_t init_pid;
+	char tag[DEV_NS_TAG_LEN + 1];
+	struct blocking_notifier_head notifiers;
+	unsigned long timestamp; /* jiffies */
+
+	struct mutex mutex;
+	struct dev_ns_info *info[DEV_NS_DESC_MAX];
+};
+
+struct dev_ns_info {
+	struct dev_namespace *dev_ns;
+	struct list_head list;
+	struct notifier_block nb;
+	atomic_t count;
+};
+
+#ifdef CONFIG_DEV_NS
+
+struct dev_ns_ops {
+	struct dev_ns_info *(*create) (struct dev_namespace *dev_ns);
+	void (*release) (struct dev_ns_info *dev_ns_info);
+};
+
+/* device namespace notifications */
+#define DEV_NS_EVENT_ACTIVATE		0x1
+#define DEV_NS_EVENT_DEACTIVATE		0x2
+
+extern struct dev_namespace init_dev_ns;
+extern struct dev_namespace *active_dev_ns;
+
+extern void __put_dev_ns(struct dev_namespace *dev_ns);
+
+static inline void put_dev_ns(struct dev_namespace *dev_ns)
+{
+	if (atomic_dec_and_test(&dev_ns->count))
+		__put_dev_ns(dev_ns);
+}
+
+static inline struct dev_namespace *get_dev_ns(struct dev_namespace *dev_ns)
+{
+	atomic_inc(&dev_ns->count);
+	return dev_ns;
+}
+
+/* return the device namespaces of the current process */
+static inline struct dev_namespace *current_dev_ns(void)
+{
+	BUG_ON(in_interrupt());
+	return current->nsproxy->dev_ns;
+}
+
+/* return whether given device namespace is active */
+static inline bool is_active_dev_ns(struct dev_namespace *dev_ns)
+{
+	return dev_ns->active;
+}
+
+/* return whether given device namespace is init dev_ns */
+static inline bool is_init_dev_ns(struct dev_namespace *dev_ns)
+{
+	return dev_ns == &init_dev_ns;
+}
+
+/* return and get the device namespace of a given task */
+extern struct dev_namespace *get_dev_ns_by_task(struct task_struct *task);
+extern struct dev_namespace *get_dev_ns_by_vpid(pid_t vpid);
+
+/*
+ * set_active_dev_ns() will lock and unlock dev_namespace_lock
+ * and call all registered activate and inactivate notifiers.
+ */
+extern void set_active_dev_ns(struct dev_namespace *dev_ns);
+
+/* return the tag of the current namespace */
+extern void get_dev_ns_tag(char *to, struct dev_namespace *dev);
+
+/* return root pid of the init process in a device namespace */
+static inline pid_t dev_ns_init_pid(struct dev_namespace *dev_ns)
+{
+	return dev_ns->init_pid;
+}
+
+/* device namespaces: notifiers (de)registration */
+extern void dev_ns_register_notify(struct dev_namespace *dev_ns,
+				   struct notifier_block *nb);
+extern void dev_ns_unregister_notify(struct dev_namespace *dev_ns,
+				     struct notifier_block *nb);
+
+extern struct dev_namespace *copy_dev_ns(unsigned long flags,
+					 struct task_struct *task);
+
+/* helpers for per-driver logic of device namespace */
+
+extern int register_dev_ns_ops(char *name, struct dev_ns_ops *ops);
+extern void unregister_dev_ns_ops(int ns_id);
+extern struct dev_ns_info *get_dev_ns_info(int ns_id,
+					   struct dev_namespace *dev_ns,
+					   bool lock, bool create);
+extern struct dev_ns_info *get_dev_ns_info_task(int ns_id,
+						struct task_struct *task);
+extern void put_dev_ns_info(int ns_id,
+			    struct dev_ns_info *dev_ns_info,
+			    int lock);
+extern void loop_dev_ns_info(int ns_id, void *ptr,
+			     void (*func)(struct dev_ns_info *dev_ns_info,
+					  void *ptr));
+
+/* macro-mania to reduce repetitive code - not for the faint of heart */
+
+#define i_to_x_dev_ns(i, x) container_of(i, struct x ## _dev_ns, dev_ns_info)
+
+#define _dev_ns_id(X) \
+	static int X ## _ns_id;
+
+#define _dev_ns_get(X) \
+	static inline \
+	struct X ## _dev_ns *get_ ## X ## _ns(struct dev_namespace *dev_ns) \
+	{ \
+		struct dev_ns_info *info; \
+		info = get_dev_ns_info(X ## _ns_id, dev_ns, 1, 1); \
+		return info ? i_to_x_dev_ns(info, X) : NULL; \
+	}
+
+#define _dev_ns_find(X) \
+	static inline \
+	struct X ## _dev_ns *find_ ## X ## _ns(struct dev_namespace *dev_ns) \
+	{ \
+		struct dev_ns_info *info; \
+		info = get_dev_ns_info(X ## _ns_id, dev_ns, 0, 0); \
+		return info ? i_to_x_dev_ns(info, X) : NULL; \
+	}
+
+
+#define _dev_ns_get_cur(X) \
+	static inline struct X ## _dev_ns *get_ ## X ## _ns_cur(void) \
+	{ \
+		struct dev_ns_info *info; \
+		info = get_dev_ns_info_task(X ## _ns_id, current); \
+		return info ? i_to_x_dev_ns(info, X) : NULL; \
+	}
+
+#define _dev_ns_put(X) \
+	static inline void put_ ## X ## _ns(struct X ## _dev_ns *X ## _ns) \
+	{ \
+		put_dev_ns_info(X ## _ns_id, &X ## _ns->dev_ns_info, 1); \
+	}
+
+/*
+ * Finally, this is what a driver author really needs to use:
+ * DEFINE_DEV_NS_INFO(X): X_ns_id, put_X_ns(), get_X_ns(), get_X_ns_cur()
+ * DEV_NS_REGISTER(X): will register X with device namespace
+ * DEV_NS_UNREGISTER(X): will unregister X from device namespace
+ */
+
+#define DEFINE_DEV_NS_INFO(X) \
+	_dev_ns_id(X) \
+	_dev_ns_find(X) \
+	_dev_ns_get(X) \
+	_dev_ns_get_cur(X) \
+	_dev_ns_put(X)
+
+#define DEV_NS_REGISTER(X, s) \
+	(X ## _ns_id = register_dev_ns_ops(s, &X ## _ns_ops))
+
+#define DEV_NS_UNREGISTER(X) \
+	unregister_dev_ns_ops(X ## _ns_id)
+
+
+#else  /* !CONFIG_DEV_NS */
+
+/* appease static assignment in kernel/nsproxy.c */
+#define init_dev_ns (*(struct dev_namespace *) NULL)
+
+static inline void put_dev_ns(struct dev_namespace *dev_ns)
+{ /* nothing */ }
+
+/*
+ * Driver authors should use this macro instead if !CONFIG_DEV_NS:
+ * DEFINE_DEV_NS_INIT(X): put_X_ns(), get_X_ns(), get_X_ns_cur()
+ */
+#define DEFINE_DEV_NS_INIT(x) \
+	static struct x ## _dev_ns init_ ## x ## _ns; \
+	static inline \
+	struct x ## _dev_ns *find_ ## x ## _ns(struct dev_namespace *dev_ns) \
+	{ return &init_ ## x ## _ns; } \
+	static inline \
+	struct x ## _dev_ns *get_ ## x ## _ns(struct dev_namespace *dev_ns) \
+	{ return &init_ ## x ## _ns; } \
+	static inline struct x ## _dev_ns *get_ ## x ## _ns_cur(void) \
+	{ return &init_ ## x ## _ns; } \
+	static inline void put_ ## x ## _ns(struct x ## _dev_ns *x ## _ns) \
+	{ /* */ }
+
+static inline struct dev_namespace *current_dev_ns(void)
+{
+	return &init_dev_ns;
+}
+
+static inline struct dev_namespace *copy_dev_ns(unsigned long flags,
+						struct task_struct *task)
+{
+	if (flags & CLONE_NEWPID)
+		return ERR_PTR(-EINVAL);
+	return task->nsproxy->dev_ns;
+}
+
+static inline bool is_active_dev_ns(struct dev_namespace *dev_ns)
+{
+	return true;
+}
+
+static inline bool is_init_dev_ns(struct dev_namespace *dev_ns)
+{
+	return true;
+}
+
+static inline pid_t dev_ns_init_pid(struct dev_namespace *dev_ns)
+{
+	return init_task.pid;
+}
+
+static inline void get_dev_ns_tag(char *to, struct dev_namespace *dev_ns)
+{
+	strcpy(to, "");
+}
+
+#endif /* CONFIG_DEV_NS */
+
+
+#endif /* __KERNEL__ */
+#endif /* _LINUX_DEV_NS_H */
diff --git a/include/linux/file.h b/include/linux/file.h
index 4d69123..62cffc0 100644
--- a/include/linux/file.h
+++ b/include/linux/file.h
@@ -19,6 +19,7 @@ struct dentry;
 struct path;
 extern struct file *alloc_file(struct path *, fmode_t mode,
 	const struct file_operations *fop);
+extern struct file *get_empty_filp(void);
 
 static inline void fput_light(struct file *file, int fput_needed)
 {
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ab779e..aabcbba 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2664,6 +2664,7 @@ extern int inode_change_ok(const struct inode *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
+extern int update_time(struct inode *, struct timespec *, int);
 extern int file_update_time(struct file *file);
 
 extern int generic_show_options(struct seq_file *m, struct dentry *root);
diff --git a/include/linux/mm.h b/include/linux/mm.h
index b57dc40..730f1b0 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1207,6 +1207,28 @@ static inline int fixup_user_fault(struct task_struct *tsk,
 }
 #endif
 
+#ifdef CONFIG_MMU
+extern void vma_do_file_update_time(struct vm_area_struct *, const char[], int);
+extern struct file *vma_do_pr_or_file(struct vm_area_struct *, const char[],
+				      int);
+extern void vma_do_get_file(struct vm_area_struct *, const char[], int);
+extern void vma_do_fput(struct vm_area_struct *, const char[], int);
+
+#define vma_file_update_time(vma)	vma_do_file_update_time(vma, __func__, \
+								__LINE__)
+#define vma_pr_or_file(vma)		vma_do_pr_or_file(vma, __func__, \
+							  __LINE__)
+#define vma_get_file(vma)		vma_do_get_file(vma, __func__, __LINE__)
+#define vma_fput(vma)			vma_do_fput(vma, __func__, __LINE__)
+#else
+extern struct file *vmr_do_pr_or_file(struct vm_region *, const char[], int);
+extern void vmr_do_fput(struct vm_region *, const char[], int);
+
+#define vmr_pr_or_file(region)		vmr_do_pr_or_file(region, __func__, \
+							  __LINE__)
+#define vmr_fput(region)		vmr_do_fput(region, __func__, __LINE__)
+#endif /* CONFIG_MMU */
+
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
 extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
 		void *buf, int len, int write);
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 6e0b286..8f374ed 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -232,6 +232,7 @@ struct vm_region {
 	unsigned long	vm_top;		/* region allocated to here */
 	unsigned long	vm_pgoff;	/* the offset in vm_file corresponding to vm_start */
 	struct file	*vm_file;	/* the backing file or NULL */
+	struct file	*vm_prfile;	/* the virtual backing file or NULL */
 
 	int		vm_usage;	/* region usage count (access under nommu_region_sem) */
 	bool		vm_icache_flushed : 1; /* true if the icache has been flushed for
@@ -300,6 +301,7 @@ struct vm_area_struct {
 	unsigned long vm_pgoff;		/* Offset (within vm_file) in PAGE_SIZE
 					   units, *not* PAGE_CACHE_SIZE */
 	struct file * vm_file;		/* File we map to (can be NULL). */
+	struct file *vm_prfile;		/* shadow of vm_file */
 	void * vm_private_data;		/* was vm_pte (shared mem) */
 
 #ifndef CONFIG_MMU
diff --git a/include/linux/nsproxy.h b/include/linux/nsproxy.h
index 35fa08f..bc6a6d0 100644
--- a/include/linux/nsproxy.h
+++ b/include/linux/nsproxy.h
@@ -33,6 +33,7 @@ struct nsproxy {
 	struct mnt_namespace *mnt_ns;
 	struct pid_namespace *pid_ns_for_children;
 	struct net 	     *net_ns;
+    struct dev_namespace *dev_ns;
 };
 extern struct nsproxy init_nsproxy;
 
diff --git a/include/linux/printk.h b/include/linux/printk.h
index d78125f..1ee140e 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -40,7 +40,7 @@ static inline const char *printk_skip_level(const char *buffer)
 #define CONSOLE_LOGLEVEL_SILENT  0 /* Mum's the word */
 #define CONSOLE_LOGLEVEL_MIN	 1 /* Minimum loglevel we let people use */
 #define CONSOLE_LOGLEVEL_QUIET	 4 /* Shhh ..., when booted with "quiet" */
-#define CONSOLE_LOGLEVEL_DEFAULT 7 /* anything MORE serious than KERN_DEBUG */
+#define CONSOLE_LOGLEVEL_DEFAULT 8 /* anything MORE serious than KERN_DEBUG */
 #define CONSOLE_LOGLEVEL_DEBUG	10 /* issue debug messages */
 #define CONSOLE_LOGLEVEL_MOTORMOUTH 15	/* You can't shut this one up */
 
diff --git a/include/linux/splice.h b/include/linux/splice.h
index da2751d..2e0fca6 100644
--- a/include/linux/splice.h
+++ b/include/linux/splice.h
@@ -83,4 +83,10 @@ extern void splice_shrink_spd(struct splice_pipe_desc *);
 extern void spd_release_page(struct splice_pipe_desc *, unsigned int);
 
 extern const struct pipe_buf_operations page_cache_pipe_buf_ops;
+
+extern long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			   loff_t *ppos, size_t len, unsigned int flags);
+extern long do_splice_to(struct file *in, loff_t *ppos,
+			 struct pipe_inode_info *pipe, size_t len,
+			 unsigned int flags);
 #endif
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index 8523f9b..11f8f74 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -56,6 +56,7 @@ header-y += atmppp.h
 header-y += atmsap.h
 header-y += atmsvc.h
 header-y += audit.h
+header-y += aufs_type.h
 header-y += auto_fs.h
 header-y += auto_fs4.h
 header-y += auxvec.h
diff --git a/init/Kconfig b/init/Kconfig
index 2081a4d..f50800c 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1216,6 +1216,16 @@ config NET_NS
 	  Allow user space to create what appear to be multiple instances
 	  of the network stack.
 
+config DEV_NS
+    bool "Device Namespaces (EXPERIMENTAL)"
+    default n
+    depends on PID_NS
+    help
+    Support device driver namespaces. This allows drivers to multiplex
+    access to its physical or logical resources. A device namespace has
+    a one-to-one relationship with a PID namespace currentlly, but this
+    will likely change in the future.
+
 endif # NAMESPACES
 
 config SCHED_AUTOGROUP
diff --git a/kernel/Makefile b/kernel/Makefile
index 17ea6d4..c7fdb88 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_CPUSETS) += cpuset.o
 obj-$(CONFIG_UTS_NS) += utsname.o
 obj-$(CONFIG_USER_NS) += user_namespace.o
 obj-$(CONFIG_PID_NS) += pid_namespace.o
+obj-$(CONFIG_DEV_NS) += dev_namespace.o
 obj-$(CONFIG_IKCONFIG) += configs.o
 obj-$(CONFIG_RESOURCE_COUNTERS) += res_counter.o
 obj-$(CONFIG_SMP) += stop_machine.o
diff --git a/kernel/dev_namespace.c b/kernel/dev_namespace.c
new file mode 100644
index 0000000..4aa76ad
--- /dev/null
+++ b/kernel/dev_namespace.c
@@ -0,0 +1,659 @@
+/*
+ * kernel/dev_namespace.c
+ *
+ * Copyright (c) 2011-2013 Cellrox Ltd. Certain portions are copyrighted by
+ * Columbia University. This program is free software licensed under the GNU
+ * General Public License Version 2 (GPL 2). You can distribute it and/or
+ * modify it under the terms of the GPL 2.
+ *
+ * Based on device_namespace.c by Jeremy C. Andrus <jeremya@cs.columbia.edu>
+ * and Christoffer Dall <cdall@cs.columbia.edu>.
+ *
+ * Device namespaces:
+ *
+ * The idea with a device namespace comes from the Android-Cells project:
+ * namespaces are utilized to create a container-like environment on Linux,
+ * and there is a notion of an 'active' namespace while other namespaces are
+ * non-active. In such a case only processes residing within the active device
+ * namespace should communicate with actual devices, where processes inside
+ * non-active containers should be able to communicate gracefully with the
+ * device driver, but not the device.
+ *
+ * The device namespace allows a device driver to register itself and pass a
+ * pointer to its device specific namespace structure and register notifiers
+ * which are called when the active namepace becomes non-active and when an
+ * non-active namespace becomes active.
+ *
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GPL 2 license for more details.
+ * The full GPL 2 License is included in this distribution in the file called
+ * COPYING
+ *
+ * Cellrox can be contacted at oss@cellrox.com
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/pid_namespace.h>
+#include <linux/dev_namespace.h>
+//#include <linux/wakelock.h>
+#include <linux/kernel.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+
+
+/* protects active namespace and switches */
+static DECLARE_RWSEM(global_dev_ns_lock);
+
+
+struct dev_namespace init_dev_ns = {
+	.active = true,
+	.count = ATOMIC_INIT(2),  /* extra reference for active_dev_ns */
+	.init_pid = 1,
+	.notifiers = BLOCKING_NOTIFIER_INIT(init_dev_ns.notifiers),
+	.timestamp = 0,
+	.mutex = __MUTEX_INITIALIZER(init_dev_ns.mutex),
+};
+EXPORT_SYMBOL_GPL(init_dev_ns);
+
+
+struct dev_namespace *active_dev_ns = &init_dev_ns;
+
+
+static void dev_ns_lock(struct dev_namespace *dev_ns)
+{
+	mutex_lock(&dev_ns->mutex);
+}
+
+static void dev_ns_unlock(struct dev_namespace *dev_ns)
+{
+	mutex_unlock(&dev_ns->mutex);
+}
+
+static struct dev_namespace *create_dev_ns(void)
+{
+	struct dev_namespace *dev_ns;
+
+	dev_ns = kzalloc(sizeof(struct dev_namespace), GFP_KERNEL);
+	if (!dev_ns)
+		return ERR_PTR(-ENOMEM);
+
+	atomic_set(&dev_ns->count, 1);
+	BLOCKING_INIT_NOTIFIER_HEAD(&dev_ns->notifiers);
+	mutex_init(&dev_ns->mutex);
+
+	/*
+	 * The pid is yet unknown, so init_pid will remain zero until
+	 * a dev_ns is accessed for the first time by get_dev_ns_by_xxx()
+	 * or new_dev_ns_info() functions.
+	 */
+
+	return dev_ns;
+}
+
+struct dev_namespace *copy_dev_ns(unsigned long flags,
+				  struct task_struct *task)
+{
+	struct dev_namespace *dev_ns = task->nsproxy->dev_ns;
+
+	/*
+	 * Couple device namespace semantics with pid-namespace.
+	 * It's convenient, and we ran out of clone flags anyway.
+	 */
+	if (!(flags & CLONE_NEWPID))
+		return get_dev_ns(dev_ns);
+	else
+		return create_dev_ns();
+}
+
+static void lazy_set_dev_ns_init_pid(struct nsproxy *nsproxy)
+{
+	/*
+	 * dev_ns->init_pid is set here, lazily, because it was
+	 * not known at creation time in copy_dev_ns() - see above.
+	 */
+	if (unlikely(nsproxy->dev_ns->init_pid == 0))
+		nsproxy->dev_ns->init_pid = nsproxy->pid_ns_for_children->child_reaper->pid;
+}
+
+void __put_dev_ns(struct dev_namespace *dev_ns)
+{
+	kfree(dev_ns);
+}
+
+static struct dev_namespace *get_dev_ns_from_nsproxy(struct nsproxy *nsproxy)
+{
+	if (nsproxy) {
+		lazy_set_dev_ns_init_pid(nsproxy);
+		return get_dev_ns(nsproxy->dev_ns);
+	} else
+		return NULL;
+}
+
+struct dev_namespace *get_dev_ns_by_task(struct task_struct *task)
+{
+	struct dev_namespace *dev_ns = NULL;
+	struct nsproxy *nsproxy;
+
+    task_lock(task);
+    nsproxy = task->nsproxy;
+	dev_ns = get_dev_ns_from_nsproxy(nsproxy);
+    task_unlock(task);
+
+	return dev_ns;
+}
+
+struct dev_namespace *get_dev_ns_by_vpid(pid_t vpid)
+{
+	struct dev_namespace *dev_ns = NULL;
+	struct task_struct *task;
+	struct nsproxy *nsproxy;
+
+	task = find_task_by_pid_ns(vpid, &init_pid_ns);
+    task_lock(task);
+	if (task) {
+		nsproxy = task->nsproxy;
+		dev_ns = get_dev_ns_from_nsproxy(nsproxy);
+	}
+    task_unlock(task);
+
+	return dev_ns;
+}
+
+/**
+ * notifications: activate/deactive device namespace
+ */
+static BLOCKING_NOTIFIER_HEAD(dev_ns_notifiers);
+void dev_ns_register_notify(struct dev_namespace *dev_ns,
+			    struct notifier_block *nb)
+{
+	if (dev_ns != NULL)
+		blocking_notifier_chain_register(&dev_ns->notifiers, nb);
+	else
+		blocking_notifier_chain_register(&dev_ns_notifiers, nb);
+}
+
+void dev_ns_unregister_notify(struct dev_namespace *dev_ns,
+			      struct notifier_block *nb)
+{
+	if (dev_ns != NULL)
+		blocking_notifier_chain_unregister(&dev_ns->notifiers, nb);
+	else
+		blocking_notifier_chain_unregister(&dev_ns_notifiers, nb);
+}
+
+/*
+ * Helpers for per-driver logic of device-namepace
+ *
+ * Drivers should embed 'struct dev_ns_info' in driver-specific,
+ * per-device-namespace data, e.g.:
+ *
+ *   struct xxxx_namespace {
+ *     ... (data specific to xxxx)
+ *     struct dev_ns_info devns_info;
+ *   };
+ *
+ * Drivers should register a 'struct dev_ns_ops' with ->create()
+ * and ->release() methods, and keep an identifier (dev_ns_xxx_id),
+ * for use by device namespace generic code
+ *
+ * Drivers can iterate over per-driver data in all namespaces:
+ *   void loop_dev_ns_info(int dev_ns_id, void *ptr,
+ *              void (*func)(struct dev_ns_info *dev_ns_info, void *ptr))
+ *
+ * See include/linux/dev_namespace.h for helper macros to hide these details.
+ */
+
+struct dev_ns_desc {
+	char *name;
+	struct dev_ns_ops *ops;
+	struct list_head head;
+};
+
+static struct dev_ns_desc dev_ns_desc[DEV_NS_DESC_MAX];
+static DEFINE_SPINLOCK(dev_ns_desc_lock);
+
+int register_dev_ns_ops(char *name, struct dev_ns_ops *ops)
+{
+	struct dev_ns_desc *desc;
+	int n, ret = -ENOMEM;
+
+	if (!name)
+		return -EINVAL;
+
+	spin_lock(&dev_ns_desc_lock);
+	for (n = 0; n < DEV_NS_DESC_MAX; n++) {
+		desc = &dev_ns_desc[n];
+		if (!desc->name && ret < 0)
+			ret = n;
+		else if (desc->name && !strcmp(desc->name, name)) {
+			ret = -EBUSY;
+			break;
+		}
+	}
+	if (ret >= 0) {
+		pr_info("dev_ns: register info %s\n", name);
+		desc = &dev_ns_desc[ret];
+		desc->name = name;
+		desc->ops = ops;
+		INIT_LIST_HEAD(&desc->head);
+	}
+	spin_unlock(&dev_ns_desc_lock);
+
+	return ret;
+}
+
+void unregister_dev_ns_ops(int dev_ns_id)
+{
+	struct dev_ns_desc *desc = &dev_ns_desc[dev_ns_id];
+
+	spin_lock(&dev_ns_desc_lock);
+	pr_info("dev_ns: unregister desc %s\n", desc->name);
+	memset(&dev_ns_desc[dev_ns_id], 0, sizeof(*desc));
+	spin_unlock(&dev_ns_desc_lock);
+}
+
+/* this function is called with dev_ns_lock(dev_ns) held */
+static struct dev_ns_info *new_dev_ns_info(int dev_ns_id,
+					   struct dev_namespace *dev_ns)
+{
+	struct dev_ns_desc *desc = &dev_ns_desc[dev_ns_id];
+	struct dev_ns_info *dev_ns_info;
+
+	pr_debug("dev_ns: [0x%p] new info %s\n", dev_ns, desc->name);
+
+	lazy_set_dev_ns_init_pid(current->nsproxy);
+
+	dev_ns_info = desc->ops->create(dev_ns);
+	if (!dev_ns_info)
+		return NULL;
+
+	pr_debug("dev_ns: [0x%p] got info 0x%p\n", dev_ns, dev_ns_info);
+
+	dev_ns->info[dev_ns_id] = dev_ns_info;
+	dev_ns_info->dev_ns = get_dev_ns(dev_ns);
+	atomic_set(&dev_ns_info->count, 0);
+
+	spin_lock(&dev_ns_desc_lock);
+	list_add(&dev_ns_info->list, &desc->head);
+	spin_unlock(&dev_ns_desc_lock);
+
+	return dev_ns_info;
+}
+
+/* this function is called with dev_ns_lock(dev_ns) held */
+static void del_dev_ns_info(int dev_ns_id, struct dev_ns_info *dev_ns_info)
+{
+	struct dev_namespace *dev_ns = dev_ns_info->dev_ns;
+
+	pr_debug("dev_ns: [0x%p] destory info 0x%p\n", dev_ns, dev_ns_info);
+
+	spin_lock(&dev_ns_desc_lock);
+	list_del(&dev_ns_info->list);
+	dev_ns->info[dev_ns_id] = NULL;
+	spin_unlock(&dev_ns_desc_lock);
+
+	dev_ns_desc[dev_ns_id].ops->release(dev_ns_info);
+	put_dev_ns(dev_ns);
+}
+
+/*
+ * get_dev_ns_info() is intended for internal use only. It is exported only
+ * to enable the helper macros in dev_namepsace.h to work properly.
+ *
+ * @create tells whether to create a new instance if none is found already,
+ * or just return NULL.
+ *
+ * @lock tells whether the @dev_ns should be locked against concurrent
+ * changes, or the caller is the one responsible (in which case there is
+ * not even a need for an extra refefence count).
+ */
+struct dev_ns_info *get_dev_ns_info(int dev_ns_id,
+				    struct dev_namespace *dev_ns,
+				    bool lock, bool create)
+{
+	struct dev_ns_info *dev_ns_info;
+
+	if (lock) {
+		down_read(&global_dev_ns_lock);
+		dev_ns_lock(dev_ns);
+	}
+
+	dev_ns_info = dev_ns->info[dev_ns_id];
+
+	if (!dev_ns_info && create)
+		dev_ns_info = new_dev_ns_info(dev_ns_id, dev_ns);
+
+	if (dev_ns_info) {
+		pr_debug("dev_ns: [0x%p] get info 0x%p count %d+\n", dev_ns,
+			 dev_ns_info, atomic_read(&dev_ns_info->count));
+	}
+
+	if (dev_ns_info && lock)
+		atomic_inc(&dev_ns_info->count);
+
+	if (lock) {
+		dev_ns_unlock(dev_ns);
+		up_read(&global_dev_ns_lock);
+	}
+
+	return dev_ns_info;
+}
+
+struct dev_ns_info *get_dev_ns_info_task(int dev_ns_id, struct task_struct *tsk)
+{
+	struct dev_ns_info *dev_ns_info;
+	struct dev_namespace *dev_ns;
+
+	dev_ns = get_dev_ns_by_task(tsk);
+	dev_ns_info = dev_ns ? get_dev_ns_info(dev_ns_id, dev_ns, 1, 1) : NULL;
+	put_dev_ns(dev_ns);
+
+	return dev_ns_info;
+}
+
+void put_dev_ns_info(int dev_ns_id, struct dev_ns_info *dev_ns_info, int lock)
+{
+	struct dev_namespace *dev_ns;
+
+	/*
+	 * keep extra reference, or else the concluding dev_ns_unlock()
+	 * could theoretically execute after the last dev_ns_put()..
+	 */
+	dev_ns = get_dev_ns(dev_ns_info->dev_ns);
+
+	if (lock) {
+		down_read(&global_dev_ns_lock);
+		dev_ns_lock(dev_ns);
+	}
+
+	pr_debug("dev_ns: [0x%p] put info 0x%p count %d-\n", dev_ns,
+		 dev_ns_info, atomic_read(&dev_ns_info->count));
+	if (atomic_dec_and_test(&dev_ns_info->count))
+		del_dev_ns_info(dev_ns_id, dev_ns_info);
+
+	if (lock) {
+		dev_ns_unlock(dev_ns);
+		up_read(&global_dev_ns_lock);
+	}
+
+	put_dev_ns(dev_ns);
+}
+
+/*
+ * @dev_ns_id: id of device namespace subsystem
+ * @ptr: data pointer to be passed to callback
+ * @func: callback for each device namespace (atomic, must not sleep)
+ */
+void loop_dev_ns_info(int dev_ns_id, void *ptr,
+		      void (*func)(struct dev_ns_info *dev_ns_info, void *ptr))
+{
+	struct dev_ns_desc *desc;
+	struct dev_ns_info *dev_ns_info;
+
+	spin_lock(&dev_ns_desc_lock);
+	desc = &dev_ns_desc[dev_ns_id];
+	list_for_each_entry(dev_ns_info, &desc->head, list) {
+		pr_debug("dev_ns: loop info 0x%p (dev_ns 0x%p) of %s\n",
+			 dev_ns_info, dev_ns_info->dev_ns, desc->name);
+		(*func)(dev_ns_info, ptr);
+	}
+	spin_unlock(&dev_ns_desc_lock);
+}
+
+/**
+ * Set the active device namespace (will call registered notifiers to
+ * allow device drivers to make device specific context store/restore)
+ *
+ * @dev_ns: The new active device namespace
+ */
+void set_active_dev_ns(struct dev_namespace *next_ns)
+{
+	struct dev_namespace *prev_ns;
+
+	BUG_ON(next_ns == NULL);
+
+	down_write(&global_dev_ns_lock);
+
+	if (next_ns == active_dev_ns)
+		goto done;
+
+	pr_info("dev_ns: activate 0x%p\n", next_ns);
+
+	prev_ns = active_dev_ns;
+
+	/*
+	 * deactivate previous dev_ns:
+	 * - set active-state of previous dev_ns to false
+	 * - call previous dev_ns's notifiers with deactivate event
+	 * - call global notifiers with deactivate event
+	 */
+
+	dev_ns_lock(prev_ns);
+
+	prev_ns->active = false;
+	prev_ns->timestamp = jiffies;
+
+	(void) blocking_notifier_call_chain(&prev_ns->notifiers,
+					    DEV_NS_EVENT_DEACTIVATE, prev_ns);
+	(void) blocking_notifier_call_chain(&dev_ns_notifiers,
+					    DEV_NS_EVENT_DEACTIVATE, prev_ns);
+
+	dev_ns_unlock(prev_ns);
+
+	/*
+	 * activate next dev_ns:
+	 * - set active-state of next dev_ns to true
+	 * - call next dev_ns's notifiers with activate event
+	 * - call global notifiers with activate event
+	 */
+
+	dev_ns_lock(next_ns);
+
+	next_ns->active = true;
+	next_ns->timestamp = jiffies;
+
+	/* make the switch */
+	active_dev_ns = next_ns;
+
+	(void) blocking_notifier_call_chain(&next_ns->notifiers,
+					    DEV_NS_EVENT_ACTIVATE, next_ns);
+	(void) blocking_notifier_call_chain(&dev_ns_notifiers,
+					    DEV_NS_EVENT_ACTIVATE, next_ns);
+
+	dev_ns_unlock(next_ns);
+
+	get_dev_ns(next_ns);
+	put_dev_ns(prev_ns);
+
+	pr_info("dev_ns: activate 0x%p done\n", next_ns);
+ done:
+	up_write(&global_dev_ns_lock);
+}
+
+void get_dev_ns_tag(char *to, struct dev_namespace *dev_ns)
+{
+	/* buf must be at least sizeof(dev_ns->tag) in size */
+	to[DEV_NS_TAG_LEN] = '\0';
+	strncpy(to, dev_ns->tag, DEV_NS_TAG_LEN);
+}
+
+void set_dev_ns_tag(struct dev_namespace *dev_ns, char *from)
+{
+	dev_ns_lock(dev_ns);
+	strncpy(dev_ns->tag, from, DEV_NS_TAG_LEN);
+	dev_ns_unlock(dev_ns);
+}
+
+
+/**
+ * Setup for /proc/dev_ns
+ */
+
+static struct proc_dir_entry *proc_dev_ns_dir;
+
+struct proc_dir_entry *
+create_dev_ns_proc(const char *name, const struct file_operations *fops)
+{
+	struct proc_dir_entry *entry;
+	entry = proc_create(name, 0, proc_dev_ns_dir, fops);
+	return entry;
+}
+
+static int proc_active_ns_show(struct seq_file *seq, void *offset)
+{
+	down_read(&global_dev_ns_lock);
+	seq_printf(seq, "%d\n", dev_ns_init_pid(active_dev_ns));
+	up_read(&global_dev_ns_lock);
+	return 0;
+}
+
+static int proc_ns_tag_show(struct seq_file *seq, void *offset)
+{
+	down_read(&global_dev_ns_lock);
+	seq_printf(seq, "active: %d timestamp: %ld tag: %s\n",
+		   dev_ns_init_pid(active_dev_ns),
+		   active_dev_ns->timestamp,
+		   active_dev_ns->tag);
+	up_read(&global_dev_ns_lock);
+	return 0;
+}
+
+static bool dev_ns_proc_permission(void)
+{
+	return current_dev_ns() == &init_dev_ns;
+}
+
+static int proc_active_ns_open(struct inode *inode, struct file *file)
+{
+	if (!dev_ns_proc_permission())
+		return -EPERM;
+	return single_open(file, proc_active_ns_show, PDE_DATA(inode));
+}
+
+static int proc_ns_tag_open(struct inode *inode, struct file *file)
+{
+	if (!dev_ns_proc_permission())
+		return -EPERM;
+	return single_open(file, proc_ns_tag_show, PDE_DATA(inode));
+}
+
+static ssize_t dev_ns_proc_write(struct file *file,
+				 const char __user *buffer,
+				 size_t count, loff_t *ppos, int setactive)
+{
+	struct dev_namespace *dev_ns;
+	char strbuf[16]; /* 10 chars for 32-bit pid + ':' + 4 chars for tag */
+	char *pid_str, *tag_str;
+	pid_t new_pid = 0;
+
+	/* only init ns may change active ns */
+	if (!dev_ns_proc_permission())
+		return -EPERM;
+
+	if (count >= sizeof(strbuf) || count == 0)
+		return -EFAULT;
+
+	if (copy_from_user(strbuf, buffer, count))
+		return -EFAULT;
+
+	strbuf[count] = '\0';
+	pid_str = strim(strbuf);
+	tag_str = strchr(pid_str, ':');
+	if (tag_str)
+		*(tag_str++) = '\0';
+
+	if (kstrtoint(pid_str, 10, &new_pid) || !new_pid) {
+		pr_warning("dev_ns: bad PID format '%s'\n", pid_str);
+		return -EINVAL;
+	}
+
+	dev_ns = get_dev_ns_by_vpid(new_pid);
+	if (!dev_ns) {
+		pr_warning("dev_ns: non-existing PID %d\n", new_pid);
+		return -EINVAL;
+	}
+
+	if (setactive) {
+		set_active_dev_ns(dev_ns);
+	} else if (tag_str) {
+		/* set dev_ns tag if format was <pid>:<tag> */
+		/* (safe: last byte of tag always remains NULL) */
+		set_dev_ns_tag(dev_ns, tag_str);
+	} else {
+		pr_warning("dev_ns: bad PID:tag format '%s'\n", pid_str);
+		count = -EINVAL;
+	}
+
+	put_dev_ns(dev_ns);
+	return count;
+}
+
+static ssize_t proc_active_ns_write(struct file *file,
+				    const char __user *buffer,
+				    size_t count, loff_t *ppos)
+{
+	return dev_ns_proc_write(file, buffer, count, ppos, 1);
+}
+
+static ssize_t proc_ns_tag_write(struct file *file,
+				 const char __user *buffer,
+				 size_t count, loff_t *ppos)
+{
+	return dev_ns_proc_write(file, buffer, count, ppos, 0);
+}
+
+static const struct file_operations active_ns_fileops = {
+	.owner = THIS_MODULE,
+	.open = proc_active_ns_open,
+	.read = seq_read,
+	.write = proc_active_ns_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static const struct file_operations ns_tag_fileops = {
+	.owner = THIS_MODULE,
+	.open = proc_ns_tag_open,
+	.read = seq_read,
+	.write = proc_ns_tag_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static __init int dev_namespace_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	proc_dev_ns_dir = proc_mkdir("dev_ns", NULL);
+	if (!proc_dev_ns_dir)
+		return -ENOMEM;
+
+	entry = proc_create("active_ns_pid", 0644, proc_dev_ns_dir,
+			    &active_ns_fileops);
+	if (!entry)
+		goto out_fail_active_ns;
+
+	entry = proc_create("ns_tag", 0644, proc_dev_ns_dir,
+			    &ns_tag_fileops);
+	if (!entry)
+		goto out_fail_ns_tag;
+
+	return 0;
+
+out_fail_ns_tag:
+	remove_proc_entry("active_ns_pid", proc_dev_ns_dir);
+out_fail_active_ns:
+	remove_proc_entry("dev_ns", NULL);
+	return -ENOMEM;
+}
+
+device_initcall(dev_namespace_init);
diff --git a/kernel/fork.c b/kernel/fork.c
index f7f83a1..212ebcd 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -446,7 +446,7 @@ static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
 			struct inode *inode = file_inode(file);
 			struct address_space *mapping = file->f_mapping;
 
-			get_file(file);
+			vma_get_file(tmp);
 			if (tmp->vm_flags & VM_DENYWRITE)
 				atomic_dec(&inode->i_writecount);
 			mutex_lock(&mapping->i_mmap_mutex);
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index ef42d0a..4482bbf 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -22,6 +22,7 @@
 #include <linux/pid_namespace.h>
 #include <net/net_namespace.h>
 #include <linux/ipc_namespace.h>
+#include <linux/dev_namespace.h>
 #include <linux/proc_ns.h>
 #include <linux/file.h>
 #include <linux/syscalls.h>
@@ -39,6 +40,7 @@ struct nsproxy init_nsproxy = {
 #ifdef CONFIG_NET
 	.net_ns			= &init_net,
 #endif
+    .dev_ns         = &init_dev_ns,
 };
 
 static inline struct nsproxy *create_nsproxy(void)
@@ -97,9 +99,18 @@ static struct nsproxy *create_new_namespaces(unsigned long flags,
 		err = PTR_ERR(new_nsp->net_ns);
 		goto out_net;
 	}
+    
+    new_nsp->dev_ns = copy_dev_ns(flags, tsk);
+    if(IS_ERR(new_nsp->dev_ns)) {
+        err = PTR_ERR(new_nsp->dev_ns);
+        goto out_dev;
+    }
 
 	return new_nsp;
 
+out_dev:
+    if (new_nsp->net_ns)
+        put_net(new_nsp->net_ns);
 out_net:
 	if (new_nsp->pid_ns_for_children)
 		put_pid_ns(new_nsp->pid_ns_for_children);
@@ -166,6 +177,8 @@ void free_nsproxy(struct nsproxy *ns)
 	if (ns->pid_ns_for_children)
 		put_pid_ns(ns->pid_ns_for_children);
 	put_net(ns->net_ns);
+    if(ns->dev_ns)
+        put_dev_ns(ns->dev_ns);
 	kmem_cache_free(nsproxy_cachep, ns);
 }
 
diff --git a/mm/Makefile b/mm/Makefile
index 8405eb0..e0bda2d 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -18,7 +18,7 @@ obj-y			:= filemap.o mempool.o oom_kill.o \
 			   mm_init.o mmu_context.o percpu.o slab_common.o \
 			   compaction.o vmacache.o \
 			   interval_tree.o list_lru.o workingset.o \
-			   iov_iter.o debug.o $(mmu-y)
+			   iov_iter.o prfile.o debug.o $(mmu-y)
 
 obj-y += init-mm.o
 
diff --git a/mm/filemap.c b/mm/filemap.c
index 14b4642..99bc835 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -2067,7 +2067,7 @@ int filemap_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 	int ret = VM_FAULT_LOCKED;
 
 	sb_start_pagefault(inode->i_sb);
-	file_update_time(vma->vm_file);
+	vma_file_update_time(vma);
 	lock_page(page);
 	if (page->mapping != inode->i_mapping) {
 		unlock_page(page);
diff --git a/mm/fremap.c b/mm/fremap.c
index 72b8fa3..a00bbf0 100644
--- a/mm/fremap.c
+++ b/mm/fremap.c
@@ -224,16 +224,28 @@ get_write_lock:
 		 */
 		if (mapping_cap_account_dirty(mapping)) {
 			unsigned long addr;
-			struct file *file = get_file(vma->vm_file);
+			struct file *file = vma->vm_file,
+				*prfile = vma->vm_prfile;
+
 			/* mmap_region may free vma; grab the info now */
 			vm_flags = vma->vm_flags;
 
+			vma_get_file(vma);
 			addr = mmap_region(file, start, size, vm_flags, pgoff);
-			fput(file);
+			vma_fput(vma);
 			if (IS_ERR_VALUE(addr)) {
 				err = addr;
 			} else {
 				BUG_ON(addr != start);
+				if (prfile) {
+					struct vm_area_struct *new_vma;
+
+					new_vma = find_vma(mm, addr);
+					if (!new_vma->vm_prfile)
+						new_vma->vm_prfile = prfile;
+					if (new_vma != vma)
+						get_file(prfile);
+				}
 				err = 0;
 			}
 			goto out_freed;
diff --git a/mm/madvise.c b/mm/madvise.c
index 0938b30..0b66856 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -324,12 +324,12 @@ static long madvise_remove(struct vm_area_struct *vma,
 	 * vma's reference to the file) can go away as soon as we drop
 	 * mmap_sem.
 	 */
-	get_file(f);
+	vma_get_file(vma);
 	up_read(&current->mm->mmap_sem);
 	error = do_fallocate(f,
 				FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,
 				offset, end - start);
-	fput(f);
+	vma_fput(vma);
 	down_read(&current->mm->mmap_sem);
 	return error;
 }
diff --git a/mm/memory.c b/mm/memory.c
index d5f2ae9..0830a96 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2163,7 +2163,7 @@ reuse:
 			set_page_dirty_balance(dirty_page);
 			/* file_update_time outside page_lock */
 			if (vma->vm_file)
-				file_update_time(vma->vm_file);
+				vma_file_update_time(vma);
 		}
 		put_page(dirty_page);
 		if (page_mkwrite) {
diff --git a/mm/mmap.c b/mm/mmap.c
index ae91989..e3bee5c 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -277,7 +277,7 @@ static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)
 	if (vma->vm_ops && vma->vm_ops->close)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file)
-		fput(vma->vm_file);
+		vma_fput(vma);
 	mpol_put(vma_policy(vma));
 	kmem_cache_free(vm_area_cachep, vma);
 	return next;
@@ -895,7 +895,7 @@ again:			remove_next = 1 + (end > next->vm_end);
 	if (remove_next) {
 		if (file) {
 			uprobe_munmap(next, next->vm_start, next->vm_end);
-			fput(file);
+			vma_fput(vma);
 		}
 		if (next->anon_vma)
 			anon_vma_merge(vma, next);
@@ -1680,8 +1680,8 @@ out:
 	return addr;
 
 unmap_and_free_vma:
+	vma_fput(vma);
 	vma->vm_file = NULL;
-	fput(file);
 
 	/* Undo any partial mapping done by a device driver. */
 	unmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);
@@ -2477,7 +2477,7 @@ static int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,
 		goto out_free_mpol;
 
 	if (new->vm_file)
-		get_file(new->vm_file);
+		vma_get_file(new);
 
 	if (new->vm_ops && new->vm_ops->open)
 		new->vm_ops->open(new);
@@ -2496,7 +2496,7 @@ static int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,
 	if (new->vm_ops && new->vm_ops->close)
 		new->vm_ops->close(new);
 	if (new->vm_file)
-		fput(new->vm_file);
+		vma_fput(new);
 	unlink_anon_vmas(new);
  out_free_mpol:
 	mpol_put(vma_policy(new));
@@ -2886,7 +2886,7 @@ struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,
 			if (anon_vma_clone(new_vma, vma))
 				goto out_free_mempol;
 			if (new_vma->vm_file)
-				get_file(new_vma->vm_file);
+				vma_get_file(new_vma);
 			if (new_vma->vm_ops && new_vma->vm_ops->open)
 				new_vma->vm_ops->open(new_vma);
 			vma_link(mm, new_vma, prev, rb_link, rb_parent);
diff --git a/mm/msync.c b/mm/msync.c
index 992a167..ce1915b 100644
--- a/mm/msync.c
+++ b/mm/msync.c
@@ -84,13 +84,13 @@ SYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)
 		start = vma->vm_end;
 		if ((flags & MS_SYNC) && file &&
 				(vma->vm_flags & VM_SHARED)) {
-			get_file(file);
+			vma_get_file(vma);
 			up_read(&mm->mmap_sem);
 			if (vma->vm_flags & VM_NONLINEAR)
 				error = vfs_fsync(file, 1);
 			else
 				error = vfs_fsync_range(file, fstart, fend, 1);
-			fput(file);
+			vma_fput(vma);
 			if (error || start >= end)
 				goto out;
 			down_read(&mm->mmap_sem);
diff --git a/mm/nommu.c b/mm/nommu.c
index bd1808e..c9ea035 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -658,7 +658,7 @@ static void __put_nommu_region(struct vm_region *region)
 		up_write(&nommu_region_sem);
 
 		if (region->vm_file)
-			fput(region->vm_file);
+			vmr_fput(region);
 
 		/* IO memory and memory shared directly out of the pagecache
 		 * from ramfs/tmpfs mustn't be released here */
@@ -823,7 +823,7 @@ static void delete_vma(struct mm_struct *mm, struct vm_area_struct *vma)
 	if (vma->vm_ops && vma->vm_ops->close)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file)
-		fput(vma->vm_file);
+		vma_fput(vma);
 	put_nommu_region(vma->vm_region);
 	kmem_cache_free(vm_area_cachep, vma);
 }
@@ -1385,7 +1385,7 @@ unsigned long do_mmap_pgoff(struct file *file,
 					goto error_just_free;
 				}
 			}
-			fput(region->vm_file);
+			vmr_fput(region);
 			kmem_cache_free(vm_region_jar, region);
 			region = pregion;
 			result = start;
@@ -1461,10 +1461,10 @@ error_just_free:
 	up_write(&nommu_region_sem);
 error:
 	if (region->vm_file)
-		fput(region->vm_file);
+		vmr_fput(region);
 	kmem_cache_free(vm_region_jar, region);
 	if (vma->vm_file)
-		fput(vma->vm_file);
+		vma_fput(vma);
 	kmem_cache_free(vm_area_cachep, vma);
 	kleave(" = %d", ret);
 	return ret;
diff --git a/security/commoncap.c b/security/commoncap.c
index 42e712e..805f984 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -990,9 +990,11 @@ int cap_mmap_addr(unsigned long addr)
 	}
 	return ret;
 }
+EXPORT_SYMBOL(cap_mmap_addr);
 
 int cap_mmap_file(struct file *file, unsigned long reqprot,
 		  unsigned long prot, unsigned long flags)
 {
 	return 0;
 }
+EXPORT_SYMBOL(cap_mmap_file);
diff --git a/security/device_cgroup.c b/security/device_cgroup.c
index 188c1d2..426d9af 100644
--- a/security/device_cgroup.c
+++ b/security/device_cgroup.c
@@ -7,6 +7,7 @@
 #include <linux/device_cgroup.h>
 #include <linux/cgroup.h>
 #include <linux/ctype.h>
+#include <linux/export.h>
 #include <linux/list.h>
 #include <linux/uaccess.h>
 #include <linux/seq_file.h>
@@ -849,6 +850,7 @@ int __devcgroup_inode_permission(struct inode *inode, int mask)
 	return __devcgroup_check_permission(type, imajor(inode), iminor(inode),
 			access);
 }
+EXPORT_SYMBOL(__devcgroup_inode_permission);
 
 int devcgroup_inode_mknod(int mode, dev_t dev)
 {
diff --git a/security/security.c b/security/security.c
index 18b35c6..12c67af 100644
--- a/security/security.c
+++ b/security/security.c
@@ -407,6 +407,7 @@ int security_path_rmdir(struct path *dir, struct dentry *dentry)
 		return 0;
 	return security_ops->path_rmdir(dir, dentry);
 }
+EXPORT_SYMBOL(security_path_rmdir);
 
 int security_path_unlink(struct path *dir, struct dentry *dentry)
 {
@@ -423,6 +424,7 @@ int security_path_symlink(struct path *dir, struct dentry *dentry,
 		return 0;
 	return security_ops->path_symlink(dir, dentry, old_name);
 }
+EXPORT_SYMBOL(security_path_symlink);
 
 int security_path_link(struct dentry *old_dentry, struct path *new_dir,
 		       struct dentry *new_dentry)
@@ -431,6 +433,7 @@ int security_path_link(struct dentry *old_dentry, struct path *new_dir,
 		return 0;
 	return security_ops->path_link(old_dentry, new_dir, new_dentry);
 }
+EXPORT_SYMBOL(security_path_link);
 
 int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
 			 struct path *new_dir, struct dentry *new_dentry,
@@ -458,6 +461,7 @@ int security_path_truncate(struct path *path)
 		return 0;
 	return security_ops->path_truncate(path);
 }
+EXPORT_SYMBOL(security_path_truncate);
 
 int security_path_chmod(struct path *path, umode_t mode)
 {
@@ -465,6 +469,7 @@ int security_path_chmod(struct path *path, umode_t mode)
 		return 0;
 	return security_ops->path_chmod(path, mode);
 }
+EXPORT_SYMBOL(security_path_chmod);
 
 int security_path_chown(struct path *path, kuid_t uid, kgid_t gid)
 {
@@ -472,6 +477,7 @@ int security_path_chown(struct path *path, kuid_t uid, kgid_t gid)
 		return 0;
 	return security_ops->path_chown(path, uid, gid);
 }
+EXPORT_SYMBOL(security_path_chown);
 
 int security_path_chroot(struct path *path)
 {
@@ -557,6 +563,7 @@ int security_inode_readlink(struct dentry *dentry)
 		return 0;
 	return security_ops->inode_readlink(dentry);
 }
+EXPORT_SYMBOL(security_inode_readlink);
 
 int security_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
@@ -571,6 +578,7 @@ int security_inode_permission(struct inode *inode, int mask)
 		return 0;
 	return security_ops->inode_permission(inode, mask);
 }
+EXPORT_SYMBOL(security_inode_permission);
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
@@ -693,6 +701,7 @@ int security_file_permission(struct file *file, int mask)
 
 	return fsnotify_perm(file, mask);
 }
+EXPORT_SYMBOL(security_file_permission);
 
 int security_file_alloc(struct file *file)
 {
@@ -753,6 +762,7 @@ int security_mmap_file(struct file *file, unsigned long prot,
 		return ret;
 	return ima_file_mmap(file, prot);
 }
+EXPORT_SYMBOL(security_mmap_file);
 
 int security_mmap_addr(unsigned long addr)
 {
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index b21988f..0334963 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -472,7 +472,8 @@ static int sb_finish_set_opts(struct super_block *sb)
 	 * setting SELinux context on in-core inodes.
 	 */
 	if (strncmp(sb->s_type->name, "rootfs", sizeof("rootfs")) == 0)
-		sbsec->flags |= SE_SBLABELSUPP;
+	//	sbsec->flags |= SE_SBLABELSUPP;
+		sbsec->flags |= SBLABEL_MNT;
 
 	/* Initialize the root inode. */
 	rc = inode_doinit_with_dentry(root_inode, root);

project libcore/
diff --git a/libart/src/main/java/java/lang/Enum.java b/libart/src/main/java/java/lang/Enum.java
index f98554a..43ac113 100644
--- a/libart/src/main/java/java/lang/Enum.java
+++ b/libart/src/main/java/java/lang/Enum.java
@@ -148,7 +148,7 @@ public abstract class Enum<E extends Enum<E>> implements Serializable, Comparabl
      * @see java.lang.Comparable
      */
     public final int compareTo(E o) {
-        return ordinal - o.ordinal;
+        return ordinal - o.ordinal();
     }
 
     /**
diff --git a/libdvm/src/main/java/java/lang/Enum.java b/libdvm/src/main/java/java/lang/Enum.java
index 7a0f514..4b897aa 100644
--- a/libdvm/src/main/java/java/lang/Enum.java
+++ b/libdvm/src/main/java/java/lang/Enum.java
@@ -147,7 +147,7 @@ public abstract class Enum<E extends Enum<E>> implements Serializable, Comparabl
      * @see java.lang.Comparable
      */
     public final int compareTo(E o) {
-        return ordinal - o.ordinal;
+        return ordinal - o.ordinal();
     }
 
     /**

project system/netd/
diff --git a/BandwidthController.cpp b/BandwidthController.cpp
index 664211d..2641b42 100644
--- a/BandwidthController.cpp
+++ b/BandwidthController.cpp
@@ -137,7 +137,7 @@ const char *BandwidthController::IPT_SETUP_COMMANDS[] = {
 };
 
 const char *BandwidthController::IPT_BASIC_ACCOUNTING_COMMANDS[] = {
-    "-A bw_INPUT -m owner --socket-exists", /* This is a tracking rule. */
+    //"-A bw_INPUT -m owner --socket-exists", /* This is a tracking rule. */
 
     "-A bw_OUTPUT -m owner --socket-exists", /* This is a tracking rule. */
 
diff --git a/MDnsSdListener.cpp b/MDnsSdListener.cpp
index 4944e18..e37ed76 100644
--- a/MDnsSdListener.cpp
+++ b/MDnsSdListener.cpp
@@ -43,15 +43,15 @@
 
 MDnsSdListener::MDnsSdListener() :
                  FrameworkListener("mdns", true) {
-    Monitor *m = new Monitor();
-    registerCmd(new Handler(m, this));
+//    Monitor *m = new Monitor();
+//    registerCmd(new Handler(m, this));
 }
 
 MDnsSdListener::Handler::Handler(Monitor *m, MDnsSdListener *listener) :
    NetdCommand("mdnssd") {
-   if (DBG) ALOGD("MDnsSdListener::Hander starting up");
-   mMonitor = m;
-   mListener = listener;
+//   if (DBG) ALOGD("MDnsSdListener::Hander starting up");
+//   mMonitor = m;
+//   mListener = listener;
 }
 
 MDnsSdListener::Handler::~Handler() {}
